\newcommand{\NWtarget}[2]{\hypertarget{#1}{#2}}
\newcommand{\NWlink}[2]{\hyperlink{#1}{#2}}
\newcommand{\NWtxtMacroDefBy}{Fragment defined by}
\newcommand{\NWtxtMacroRefIn}{Fragment referenced in}
\newcommand{\NWtxtMacroNoRef}{Fragment never referenced}
\newcommand{\NWtxtDefBy}{Defined by}
\newcommand{\NWtxtRefIn}{Referenced in}
\newcommand{\NWtxtNoRef}{Not referenced}
\newcommand{\NWtxtFileDefBy}{File defined by}
\newcommand{\NWtxtIdentsUsed}{Uses:}
\newcommand{\NWtxtIdentsNotUsed}{Never used}
\newcommand{\NWtxtIdentsDefed}{Defines:}
\newcommand{\NWsep}{${\diamond}$}
\newcommand{\NWnotglobal}{(not defined globally)}
\newcommand{\NWuseHyperlinks}{}
\documentclass[12.0pt]{report}
\input{standard_settings.tex}

\usepackage{harpoon}% <---


%%% Super useful for marking todo notes, ripped from here: 
%%% https://tex.stackexchange.com/a/178806/17858
\usepackage{xargs}                      % Use more than one optional parameter in a new commands
\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}
\newcommandx{\UNSURE}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=blue,#1]{#2}}
\newcommandx{\TODO}[2][1=]{\todo[linecolor=red,backgroundcolor=red!25,bordercolor=red,#1]{#2}}

\usepackage{kantlipsum}
\usepackage{fancyvrb}
\usepackage{setspace}
\newenvironment{CVerbatim}
 {\singlespacing\center\BVerbatim}
 {\endBVerbatim\endcenter}

\usepackage{tocloft}
\renewcommand{\cftpartfont}{\LARGE\itshape} % Part title in Huge Italic font
\usepackage{hyperref}
\usepackage{etoolbox}
% Better formatting of backticks in 
% verbatim environment. 
\usepackage{upquote}

% page numbering at top right
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[R]{\thepage}

\begin{document}
\begin{titlepage}
	\centering
        {\Huge Analyses of Experimental Heuristics for Package-Handoff Type Problems\\}
        \vspace{20mm}
        {\Large Gaurish Telang}
\end{titlepage}
\pagenumbering{arabic}
\setcounter{page}{2} 
\setcounter{tocdepth}{1}
\tableofcontents
\addtocontents{toc}{~\hfill\textbf{Page}\par}

\chapter{Overview}

How do you get a package from point $A$ to point $B$ with a fleet of carrier drones each 
capable of various maximum speeds? This is the question we try to answer in some of  
its various avatars by developing algorithms, heuristics, local optimality heuristics 
and lower-bounds. 

Specifically, we are given as input the positions $P_i$ of $n$ drones (labelled 1 through $n$) 
in the plane each capable of a maximum speed of $u_i$. Also given is a package present 
at $S$ that needs to get to $T$. Each drone is capable of picking up the package and 
flying with speed $u_i$ to another point to hand the package off to another drone. 

\begin{figure}[H]
    \centering
    \subfloat[An example of a carrier drone. Image taken from \cite{Franceha10:online}]{{\includegraphics[width=5cm]{images/carrier-drone.jpg} }}%
    \qquad
    \subfloat[A fleet of drones such as on the left, coordinating to move a package from $S$ to $T$ in the least time possible.]{{\includegraphics[width=5cm]{example-image-b} }}%
    \caption{An instance of the Package Handoff problem for a single package}%
    \label{single-pho-example}%
\end{figure}


The challenge is to figure how to get the drones to cooperate to send 
the package from $S$ to $T$ in the least possible time i.e. minimize the makespan
of the delivery process. 

To solve the problem we need to be able to do several things

\begin{itemize}
\item Figure out which subset $S = \{i_1, i_2, \ldots i_k\}$ of the drones are used in the optimal schedule. 
\item Find the order in which the handoffs happend between the drones used in a schedule. 
\item Find the ``handoff'' points when drone $i_m$ hands over the package to drone $i_{m+1}$ for all $m \leq k-1$ 
      \footnote{The final drone $i_k$ in the schedule flies with the package to the target site $T$}
\end{itemize}

This category of problems is a generalization of computing shortest paths in $\mathbb{R}^2$ 
between 
two points. As far as we know such problems have not been considered before in the 
operations research or computational geometry literature; it is, however, reminescent of 
the Weighted Region Problem \cite{mitchell1991weighted} (henceforth abbreviated as 
\texttt{WRP}) where one needs to figure out how to compute a 
shortest \textit{weighted} path between two points in the plane
that has been partitioned into convex polygonal regions, each associated with a constant 
multiplicative weight for scaling the euclidean distance between two points 
\textit{within} that region.  


The distinctive feature of this problem and its generalizations is figuring out how 
to make multiple agents of \textit{varying} capabilities  located at different points 
in $\mathbb{R}^2$ (such as maximum capable speed, battery capacity, tethering constraints 
etc.) \textit{cooperate} in transporting one or more packages most efficiently 
from their given sources to their target destinations. 

While we are framing these problems in terms of drones, one can also apply this problem 
in routing a fleet of taxis to get passengers from their pickup to their dropoff locations. 
Interesting problems might arise in this scenario itself (e.g. what if the sequence of 
pickup and dropoff locations for passengers happen in an online manner, say when passengers request or cancel rides with their 
smartphones?) We leave the investigation of these latter fascinating problems for future work. 
All problems considered in this article are in the offline setting. 


Each chapter in this document is devoted to developing algorithms for a specific 
variant of the package handoff problem (henceforth abbreviated as \texttt{PHO}), beginning 
with the plain-vanilla single package handoff problem described above. 
For most algorithms we will also be giving implementations in Python described in a 
literate-programming style \footnote{Which essentially means you will see code-snippets interleaved with the actual explanation of the algorithms. 
The code snippets are then extracted using a literate programming tool (using a so-called a ``weaver'' and ``tangler'') into an 
executable Python program} \cite{knuth1984literate} using the NuWeb literate programming tool \cite{briggs2001nuweb}  
for weaving and tangling the code-snippets. 

You can check out the Package Handoff code from the following GitHub repository: 

\begin{center}
\url{https://github.com/gtelang/PackageHandoff_Python}
\end{center}

The \texttt{README} file in the repository gives instructions on how to run the code and any of the associated experiments. 
%-----------------------------------------------------
\chapter{Single Package Handoff}
\label{chap:single-package-handoff}

In this chapter, we consider the problem posed at the beginning of the Overview chapter. For convenience
we state the problem again below

\begin{displayquote}
Given the positions $P_i$ of $n$ drones (labelled 1 through $n$) 
in $\RR^2$ each capable of a maximum speed of $u_i \geq 0$. Also given is a package present 
at $S$ that needs to get to $T$. Each drone is capable of picking up the package and 
flying with speed $u_i$ to another point to hand the package off to another drone (which in turn 
hands the package off to another drone and so on). 
 
Find the best way to coordinate the movement of the drones to get the package from $S$ to $T$ in the least 
possible time i.e. minimize the makespan of the delivery process. 

\end{displayquote} 


Note that in the optimal schedule, it is easy to construct an example such that not all drones will necessarily participate
in getting the package from $S$ to $T$. The challenge is to figure out which subset of drones to use, 
along with the handoff points. 

However, the following observations are crucial for the development of algorithms in this chapter. 

\begin{flem}

\begin{itemize}

   \item  For the single delivery package handoff problem,  a slower drone, 
          always hands off the package to a faster drone, in any optimal schedule. 
   
    \item All drones involved in the optimal schedule start moving at time $t=0$. The drone not involved 
          can remain stationary since they don't participate in the package transport. 
     
    \item No drone waits on any other drone at the rendezvous points in any optimal schedule. i.e. if two drones rendezvous at some 
          point $H$, they arrive at $H$ are precisely the same time on the clock. 

    \item The path of the package is a monotonic polygonal curve with respect to the direction $\overrightharp{ST}$
          no matter what the intial positions $P_i$ or speeds $u_i$ of the drones. 
\end{itemize}  


 \end{flem}

Thus, once we \textit{know} which drones participate in the schedule, the order in which they participate in the handoff
from start to finish is determined according to their speeds, sorted from lowest to highest. \footnote{This property is unfortunately 
not true when there are multiple packages to be delivered to their respective desitinations, even for the case where the sources
and targets for all the packages are the same. Examples where this happens are given in the next chapter.}

Before proceeding, we first fix some notation: 

\begin{itemize}
\item $(P_i, u_i)$ for $1 \leq i \leq n$ where $P_i \in \RR^2$ and $u_i \geq 0$, $S,T \in \RR^2$ respectively stand for the initial positions, speed, and source and target points for a package. 
\item $(S=H_{i_0}), H_{i_1} \ldots H_{i_k}$ for $0 \leq i_0, \ldots i_k \leq n$ stand for points where the drones with labels $i_0, \ldots i_k$ handle the package in that oder. More precisely 
      $H_{i_j}$ is the point where drone $i_{j-1}$ hands off the package to drone $i_j$ for $1 \leq j \leq k$.  
\end{itemize}





\section{Propagating Wavefront Algorithms}




The algorithms in this section are inspired by the Continuous Dijkstra paradigm used in computing shortest paths for the Weighted Region Problem
and for computing euclidean shortest paths in the presence of polygonal obstacles \cite{mitchell1991weighted, mitchell1996shortest}. 
The approximation and locality properties of these heuristics are considered later in the chapter. 




The general idea is simple: consider expanding circular wavelets centered at the positions $P_i$, each expanding with speed $u_i$. The drones invovled in the schedule
are then calculated by observing how the wavelets interact in time. The various heuristics differ according to how the subset of drones involved in the delivery 
process is figured out based on nature of the ``wavefront'' used to keep track of the current tentative location of the package. 

Once this subset of drones is calculated,  we use convex optimization (via the convex optimization modelling language CVXPY \cite{diamond2016cvxpy}) 
to figure out \textit{exactly} the handoff points for the drones involved in transporting the package from the source to the destination. 

Precise details follow in the subsections below.


\begin{algorithm}[H]
\SetAlgoLined
\KwData{$(P_i, u_i)$ for $1 \leq i \leq n$ where $P_i \in \RR^2$ and $u_i \geq 0$, $S,T \in \RR^2$  }
\KwResult{ A polygonal path $(S=H_{i_0}), H_{i_1} \ldots H_{i_k}, T$  representing the path travelled by the package. }
      
initialization\;
\While{not at end of this document}{
read current\;
\eIf{understand}{
go to next section\;
current section becomes this one\;
}{
go back to the beginning of current section\;
}
}
\caption{How to write algorithms}
\end{algorithm}




\newpage
\section{Chapter Index of Fragments}
None.

\section{Chapter Index of Identifiers}
 
%------------------------------------------------------


\bibliography{packagehandoff-main} 
\bibliographystyle{ieeetr}

\begin{appendices}
\chapter{Supporting Code}


The following file, contains some common algorithmic utilities 


%{python-mode}%
\begin{flushleft} \small\label{scrap1}\raggedright\small
\NWtarget{nuweb10}{} \verb@"../src/utils_algo.py"@\nobreak\ {\footnotesize {10}}$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@    @\\
\mbox{}\verb@ @\\
\mbox{}\verb@import numpy as np@\\
\mbox{}\verb@import random@\\
\mbox{}\verb@from colorama import Fore@\\
\mbox{}\verb@from colorama import Style@\\
\mbox{}\verb@@\\
\mbox{}\verb@def vector_chain_from_point_list(pts):@\\
\mbox{}\verb@    vec_chain = []@\\
\mbox{}\verb@    for pair in zip(pts, pts[1:]):@\\
\mbox{}\verb@        tail= np.array (pair[0])@\\
\mbox{}\verb@        head= np.array (pair[1])@\\
\mbox{}\verb@        vec_chain.append(head-tail)@\\
\mbox{}\verb@@\\
\mbox{}\verb@    return vec_chain@\\
\mbox{}\verb@@\\
\mbox{}\verb@def length_polygonal_chain(pts):@\\
\mbox{}\verb@    vec_chain = vector_chain_from_point_list(pts)@\\
\mbox{}\verb@@\\
\mbox{}\verb@    acc = 0@\\
\mbox{}\verb@    for vec in vec_chain:@\\
\mbox{}\verb@        acc = acc + np.linalg.norm(vec)@\\
\mbox{}\verb@    return acc@\\
\mbox{}\verb@def pointify_vector (x):@\\
\mbox{}\verb@    if len(x) % 2 == 0:@\\
\mbox{}\verb@        pts = []@\\
\mbox{}\verb@        for i in range(len(x))[::2]:@\\
\mbox{}\verb@            pts.append( [x[i],x[i+1]] )@\\
\mbox{}\verb@        return pts@\\
\mbox{}\verb@    else :@\\
\mbox{}\verb@        sys.exit('List of items does not have an even length to be able to be pointifyed')@\\
\mbox{}\verb@def flatten_list_of_lists(l):@\\
\mbox{}\verb@       return [item for sublist in l for item in sublist]@\\
\mbox{}\verb@def print_list(xs):@\\
\mbox{}\verb@    for x in xs:@\\
\mbox{}\verb@        print x@\\
\mbox{}\verb@def partial_sums( xs ):@\\
\mbox{}\verb@    psum = 0@\\
\mbox{}\verb@    acc = []@\\
\mbox{}\verb@    for x in xs:@\\
\mbox{}\verb@        psum = psum+x@\\
\mbox{}\verb@        acc.append( psum )@\\
\mbox{}\verb@    return acc@\\
\mbox{}\verb@def are_site_orderings_equal(sites1, sites2):@\\
\mbox{}\verb@@\\
\mbox{}\verb@    for (x1,y1), (x2,y2) in zip(sites1, sites2): @\\
\mbox{}\verb@        if (x1-x2)**2 + (y1-y2)**2 > 1e-8:@\\
\mbox{}\verb@            return False@\\
\mbox{}\verb@    return True@\\
\mbox{}\verb@def bunch_of_non_uniform_random_points(numpts):@\\
\mbox{}\verb@    cluster_size = int(np.sqrt(numpts)) @\\
\mbox{}\verb@    numcenters   = cluster_size@\\
\mbox{}\verb@    @\\
\mbox{}\verb@    import scipy@\\
\mbox{}\verb@    import random@\\
\mbox{}\verb@    centers = scipy.rand(numcenters,2).tolist()@\\
\mbox{}\verb@@\\
\mbox{}\verb@    scale, points = 4.0, []@\\
\mbox{}\verb@    for c in centers:@\\
\mbox{}\verb@        cx, cy = c[0], c[1]@\\
\mbox{}\verb@        # For current center $c$ of this loop, generate \verb|cluster_size| points uniformly in a square centered at it@\\
\mbox{}\verb@           @\\
\mbox{}\verb@        sq_size      = min(cx,1-cx,cy, 1-cy)@\\
\mbox{}\verb@        loc_pts_x    = np.random.uniform(low=cx-sq_size/scale, high=cx+sq_size/scale, size=(cluster_size,))@\\
\mbox{}\verb@        loc_pts_y    = np.random.uniform(low=cy-sq_size/scale, high=cy+sq_size/scale, size=(cluster_size,))@\\
\mbox{}\verb@        points.extend(zip(loc_pts_x, loc_pts_y))@\\
\mbox{}\verb@        @\\
\mbox{}\verb@@\\
\mbox{}\verb@    # Whatever number of points are left to be generated, generate them uniformly inside the unit-square@\\
\mbox{}\verb@       @\\
\mbox{}\verb@    num_remaining_pts = numpts - cluster_size * numcenters@\\
\mbox{}\verb@    remaining_pts = scipy.rand(num_remaining_pts, 2).tolist()@\\
\mbox{}\verb@    points.extend(remaining_pts)@\\
\mbox{}\verb@    @\\
\mbox{}\verb@@\\
\mbox{}\verb@    return points@\\
\mbox{}\verb@    @\\
\mbox{}\verb@def write_to_yaml_file(data, dir_name, file_name):@\\
\mbox{}\verb@   import yaml@\\
\mbox{}\verb@   with open(dir_name + '/' + file_name, 'w') as outfile:@\\
\mbox{}\verb@     yaml.dump( data, outfile, default_flow_style = False)@\\
\mbox{}\verb@ @\\
\mbox{}\verb@@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}

\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
%{/python-mode}%



%{python-mode}%
\begin{flushleft} \small\label{scrap2}\raggedright\small
\NWtarget{nuweb11}{} \verb@"../src/utils_graphics.py"@\nobreak\ {\footnotesize {11}}$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@    @\\
\mbox{}\verb@@\\
\mbox{}\verb@from matplotlib import rc@\\
\mbox{}\verb@from colorama import Fore@\\
\mbox{}\verb@from colorama import Style@\\
\mbox{}\verb@from scipy.optimize import minimize@\\
\mbox{}\verb@from sklearn.cluster import KMeans@\\
\mbox{}\verb@import argparse@\\
\mbox{}\verb@import itertools@\\
\mbox{}\verb@import math@\\
\mbox{}\verb@import matplotlib as mpl@\\
\mbox{}\verb@import matplotlib.pyplot as plt@\\
\mbox{}\verb@import numpy as np@\\
\mbox{}\verb@import os@\\
\mbox{}\verb@import pprint as pp@\\
\mbox{}\verb@import randomcolor @\\
\mbox{}\verb@import sys@\\
\mbox{}\verb@import time@\\
\mbox{}\verb@@\\
\mbox{}\verb@xlim, ylim = [0,1], [0,1]@\\
\mbox{}\verb@@\\
\mbox{}\verb@def applyAxCorrection(ax):@\\
\mbox{}\verb@      ax.set_xlim([xlim[0], xlim[1]])@\\
\mbox{}\verb@      ax.set_ylim([ylim[0], ylim[1]])@\\
\mbox{}\verb@      ax.set_aspect(1.0)@\\
\mbox{}\verb@@\\
\mbox{}\verb@def clearPatches(ax):@\\
\mbox{}\verb@    # Get indices cooresponding to the polygon patches@\\
\mbox{}\verb@    for index , patch in zip(range(len(ax.patches)), ax.patches):@\\
\mbox{}\verb@        if isinstance(patch, mpl.patches.Polygon) == True:@\\
\mbox{}\verb@            patch.remove()@\\
\mbox{}\verb@    ax.lines[:]=[]@\\
\mbox{}\verb@    applyAxCorrection(ax)@\\
\mbox{}\verb@@\\
\mbox{}\verb@def clearAxPolygonPatches(ax):@\\
\mbox{}\verb@@\\
\mbox{}\verb@    # Get indices cooresponding to the polygon patches@\\
\mbox{}\verb@    for index , patch in zip(range(len(ax.patches)), ax.patches):@\\
\mbox{}\verb@        if isinstance(patch, mpl.patches.Polygon) == True:@\\
\mbox{}\verb@            patch.remove()@\\
\mbox{}\verb@    ax.lines[:]=[]@\\
\mbox{}\verb@    applyAxCorrection(ax)@\\
\mbox{}\verb@def wrapperEnterRunPoints(fig, ax, run):@\\
\mbox{}\verb@    def _enterPoints(event):@\\
\mbox{}\verb@        if event.name      == 'button_press_event'          and \@\\
\mbox{}\verb@           (event.button   == 1 or event.button == 3)       and \@\\
\mbox{}\verb@            event.dblclick == True and event.xdata  != None and event.ydata  != None:@\\
\mbox{}\verb@@\\
\mbox{}\verb@             if event.button == 1:  @\\
\mbox{}\verb@                 # Insert blue circle representing a site@\\
\mbox{}\verb@                   @\\
\mbox{}\verb@                 newPoint = (event.xdata, event.ydata)@\\
\mbox{}\verb@                 run.sites.append( newPoint  )@\\
\mbox{}\verb@                 patchSize  = (xlim[1]-xlim[0])/140.0@\\
\mbox{}\verb@                    @\\
\mbox{}\verb@                 ax.add_patch( mpl.patches.Circle( newPoint, radius = patchSize,@\\
\mbox{}\verb@                                                   facecolor='blue', edgecolor='black'  ))@\\
\mbox{}\verb@                 ax.set_title('Points Inserted: ' + str(len(run.sites)), \@\\
\mbox{}\verb@                              fontdict={'fontsize':40})@\\
\mbox{}\verb@                 @\\
\mbox{}\verb@@\\
\mbox{}\verb@             elif event.button == 3:  @\\
\mbox{}\verb@                 # Insert big red circle representing initial position of horse and fly@\\
\mbox{}\verb@                  @\\
\mbox{}\verb@                 inithorseposn     = (event.xdata, event.ydata)@\\
\mbox{}\verb@                 run.inithorseposn = inithorseposn  @\\
\mbox{}\verb@                 patchSize         = (xlim[1]-xlim[0])/100.0@\\
\mbox{}\verb@@\\
\mbox{}\verb@                 ax.add_patch( mpl.patches.Circle( inithorseposn,radius = patchSize,@\\
\mbox{}\verb@                                                   facecolor= '#D13131', edgecolor='black' ))@\\
\mbox{}\verb@                 @\\
\mbox{}\verb@@\\
\mbox{}\verb@             # Clear polygon patches and set up last minute \verb|ax| tweaks@\\
\mbox{}\verb@                @\\
\mbox{}\verb@             clearAxPolygonPatches(ax)@\\
\mbox{}\verb@             applyAxCorrection(ax)@\\
\mbox{}\verb@             fig.canvas.draw()@\\
\mbox{}\verb@             @\\
\mbox{}\verb@@\\
\mbox{}\verb@    return _enterPoints@\\
\mbox{}\verb@@\\
\mbox{}\verb@# Borrowed from https://stackoverflow.com/a/9701141@\\
\mbox{}\verb@import numpy as np@\\
\mbox{}\verb@import colorsys@\\
\mbox{}\verb@@\\
\mbox{}\verb@def get_colors(num_colors, lightness=0.2):@\\
\mbox{}\verb@    colors=[]@\\
\mbox{}\verb@    for i in np.arange(60., 360., 300. / num_colors):@\\
\mbox{}\verb@        hue        = i/360.0@\\
\mbox{}\verb@        saturation = 0.95@\\
\mbox{}\verb@        colors.append(colorsys.hls_to_rgb(hue, lightness, saturation))@\\
\mbox{}\verb@    return colors@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}

\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
%{/python-mode}%
\end{appendices}

\end{document}
