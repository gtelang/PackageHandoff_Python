\newcommand{\NWtarget}[2]{\hypertarget{#1}{#2}}
\newcommand{\NWlink}[2]{\hyperlink{#1}{#2}}
\newcommand{\NWtxtMacroDefBy}{Fragment defined by}
\newcommand{\NWtxtMacroRefIn}{Fragment referenced in}
\newcommand{\NWtxtMacroNoRef}{Fragment never referenced}
\newcommand{\NWtxtDefBy}{Defined by}
\newcommand{\NWtxtRefIn}{Referenced in}
\newcommand{\NWtxtNoRef}{Not referenced}
\newcommand{\NWtxtFileDefBy}{File defined by}
\newcommand{\NWtxtIdentsUsed}{Uses:}
\newcommand{\NWtxtIdentsNotUsed}{Never used}
\newcommand{\NWtxtIdentsDefed}{Defines:}
\newcommand{\NWsep}{${\diamond}$}
\newcommand{\NWnotglobal}{(not defined globally)}
\newcommand{\NWuseHyperlinks}{}
\documentclass[10.0pt]{report}
\input{standard_settings.tex}

\usepackage{harpoon}% <---


%%% Super useful for marking todo notes, ripped from here: 
%%% https://tex.stackexchange.com/a/178806/17858
\usepackage{xargs}                      % Use more than one optional parameter in a new commands
\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}
\newcommandx{\UNSURE}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=blue,#1]{#2}}
\newcommandx{\TODO}[2][1=]{\todo[linecolor=red,backgroundcolor=red!25,bordercolor=red,#1]{#2}}

\usepackage{kantlipsum}
\usepackage{fancyvrb}
\usepackage{setspace}
\newenvironment{CVerbatim}
 {\singlespacing\center\BVerbatim}
 {\endBVerbatim\endcenter}

\usepackage{tocloft}
\renewcommand{\cftpartfont}{\LARGE\itshape} % Part title in Huge Italic font
\usepackage{hyperref}
\usepackage{etoolbox}
% Better formatting of backticks in 
% verbatim environment. 
\usepackage{upquote}

% page numbering at top right
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[R]{\thepage}

\begin{document}
\begin{titlepage}
	\centering
        {\Huge Analyses of Experimental Heuristics for Package-Handoff Type Problems\\}
        \vspace{20mm}
        {\Large Kien Huynh, J.S.B, Mitchell, Gaurish Telang}
\end{titlepage}
\pagenumbering{arabic}
\setcounter{page}{2} 
\setcounter{tocdepth}{1}
\tableofcontents
\addtocontents{toc}{~\hfill\textbf{Page}\par}

\chapter{Overview}

How do you get a package from point $A$ to point $B$ with a fleet of carrier drones each 
capable of various maximum speeds? This is the question we try to answer in some of  
its various avatars by developing algorithms, heuristics, local optimality heuristics 
and lower-bounds. 

Specifically, we are given as input the positions $P_i$ of $n$ drones (labelled 1 through $n$) 
in the plane each capable of a maximum speed of $u_i$. Also given is a package present 
at $S$ that needs to get to $T$. Each drone is capable of picking up the package and 
flying with speed $u_i$ to another point to hand the package off to another drone. 

\begin{figure}[H]
    \centering
    \subfloat[An example of a carrier drone. Image taken from \cite{Franceha10:online}]{{\includegraphics[width=5cm]{images/carrier-drone.jpg} }}%
    \qquad
    \subfloat[A fleet of drones such as on the left, coordinating to move a package from $S$ to $T$ in the least time possible.]{{\includegraphics[width=5cm]{example-image-b} }}%
    \caption{An instance of the Package Handoff problem for a single package}%
    \label{single-pho-example}%
\end{figure}


The challenge is to figure how to get the drones to cooperate to send 
the package from $S$ to $T$ in the least possible time i.e. minimize the makespan
of the delivery process. 

To solve the problem we need to be able to do several things

\begin{itemize}
\item Figure out which subset $S = \{i_1, i_2, \ldots i_k\}$ of the drones are used in the optimal schedule. 
\item Find the order in which the handoffs happend between the drones used in a schedule. 
\item Find the ``handoff'' points when drone $i_m$ hands over the package to drone $i_{m+1}$ for all $m \leq k-1$ 
      \footnote{The final drone $i_k$ in the schedule flies with the package to the target site $T$}
\end{itemize}

This category of problems is a generalization of computing shortest paths in $\mathbb{R}^2$ 
between 
two points. As far as we know such problems have not been considered before in the 
operations research or computational geometry literature; it is, however, reminescent of 
the Weighted Region Problem \cite{mitchell1991weighted} (henceforth abbreviated as 
\texttt{WRP}) where one needs to figure out how to compute a 
shortest \textit{weighted} path between two points in the plane
that has been partitioned into convex polygonal regions, each associated with a constant 
multiplicative weight for scaling the euclidean distance between two points 
\textit{within} that region.  


The distinctive feature of this problem and its generalizations is figuring out how 
to make multiple agents of \textit{varying} capabilities  located at different points 
in $\mathbb{R}^2$ (such as maximum capable speed, battery capacity, tethering constraints 
etc.) \textit{cooperate} in transporting one or more packages most efficiently 
from their given sources to their target destinations. 

While we are framing these problems in terms of drones, one can also apply this problem 
in routing a fleet of taxis to get passengers from their pickup to their dropoff locations. 
Interesting problems might arise in this scenario itself (e.g. what if the sequence of 
pickup and dropoff locations for passengers happen in an online manner, say when passengers request or cancel rides with their 
smartphones?) We leave the investigation of these latter fascinating problems for future work. 
All problems considered in this article are in the offline setting. 


Each chapter in this document is devoted to developing algorithms for a specific 
variant of the package handoff problem (henceforth abbreviated as \texttt{PHO}), beginning 
with the plain-vanilla single package handoff problem described above. 
For most algorithms we will also be giving implementations in Python described in a 
literate-programming style \footnote{Which essentially means you will see code-snippets interleaved with the actual explanation of the algorithms. 
The code snippets are then extracted using a literate programming tool (using a so-called a ``weaver'' and ``tangler'') into an 
executable Python program} \cite{knuth1984literate} using the NuWeb literate programming tool \cite{briggs2001nuweb}  
for weaving and tangling the code-snippets. 

You can check out the Package Handoff code from the following GitHub repository: 

\begin{center}
\url{https://github.com/gtelang/PackageHandoff_Python}
\end{center}

The \texttt{README} file in the repository gives instructions on how to run the code and any of the associated experiments. %-----------------------------------------------------
\chapter{Single Package Handoff}
\label{chap:single-package-handoff}

In this chapter, we consider the problem posed at the beginning of the Overview chapter. For convenience
we state the problem again below

\begin{displayquote}
Given the positions $P_i$ of $n$ drones (labelled 1 through $n$) 
in $\RR^2$ each capable of a maximum speed of $u_i \geq 0$. Also given is a package present 
at $S$ that needs to get to $T$. Each drone is capable of picking up the package and 
flying with speed $u_i$ to another point to hand the package off to another drone (which in turn 
hands the package off to another drone and so on). 
 
Find the best way to coordinate the movement of the drones to get the package from $S$ to $T$ in the least 
possible time i.e. minimize the makespan of the delivery process. 

\end{displayquote} 


Note that in the optimal schedule, it is easy to construct an example such that not all drones will necessarily participate
in getting the package from $S$ to $T$. The challenge is to figure out which subset of drones to use, 
along with the handoff points. 

However, the following observations are crucial for the development of algorithms in this chapter. 

\begin{flem}

\begin{enumerate}

   \item  For the single delivery package handoff problem,  a slower drone, 
          always hands off the package to a faster drone, in any optimal schedule. 
          Thus, once we \textit{know} which drones participate in the schedule, the order in which they participate in the handoff
          from start to finish is determined according to their speeds, sorted from lowest to highest. 
\footnote{This property is unfortunately 
not true when there are multiple packages to be delivered to their respective desitinations, even for the case where the sources
and targets for all the packages are the same. Examples where this happens are given in the next chapter.}
   
    \item All drones involved in the optimal schedule start moving at time $t=0$ at full speed along a straight line towards a handoff point . The drones not involved 
          can remain stationary since they don't participate in the package transport. 
    
    \item No drone waits on any other drone at the rendezvous points in any optimal schedule. i.e. if two drones rendezvous at some 
          point $H$, they arrive at $H$ are precisely the same time on the clock. 

    \item The path of the package is a monotonic piecewise straight polygonal curve with respect to the direction $\overrightharp{ST}$
          no matter what the intial positions $P_i$ or speeds $u_i$ of the drones. \footnote{We conjecture this property to be true 
          even for the case of multiple packages i.e. the path of travel of each package is monotonic with respect to the vectors $S_i T_i$'s}
\end{enumerate}


 \end{flem}


Before proceeding, we first fix some notation: 

\begin{itemize}
\item $(P_i, u_i)$ for $1 \leq i \leq n$ where $P_i \in \RR^2$ and $u_i \geq 0$, $S,T \in \RR^2$ respectively stand for the initial positions, speed, and source and target points for a package. 
\item $(S=H_{i_0}), H_{i_1} \ldots H_{i_k}$ for $0 \leq i_0, \ldots i_k \leq n$ stand for points where the drones with labels $i_0, \ldots i_k$ handle the package in that order. More precisely 
      $H_{i_j}$ is the point where drone $i_{j-1}$ hands off the package to drone $i_j$ for $1 \leq j \leq k$.  
\end{itemize}



\section{Wavefront Algorithms}
The algorithms in this section are inspired by the Continuous Dijkstra paradigm used in computing shortest paths for the Weighted Region Problem
and for computing euclidean shortest paths in the presence of polygonal obstacles \cite{mitchell1991weighted, mitchell1996shortest}. 
The approximation and locality properties of these heuristics are considered later in the chapter. 


The general idea is simple: consider expanding circular wavelets centered at the positions $P_i$, each expanding with speed $u_i$. The drones invovled in the schedule
are then calculated by observing how the wavelets interact in time. The various heuristics differ according to how the subset of drones involved in the delivery 
process is figured out based on nature of the ``wavefront'' used to keep track of the current tentative location of the package. 

Once this subset of drones is calculated,  we use convex optimization (via the convex optimization modelling language CVXPY \cite{diamond2016cvxpy}) 
to figure out \textit{exactly} the handoff points for the drones involved in transporting the package from the source to the destination. 

Precise details follow in the subsections below.


\subsection{Preliminary Data Structures} \hspace{10mm}

Before proceeding, lets design some housekeeping data-structures to 
represent the problem. The following data-structure simply maintains the 
information about the drones, the source and target used as input to the 
problem. To get a PHO tour for the package, algorithms are passed as 
first class values to the method \verb|get_tour| of this class. 

Note that each algorithm does its own plotting and animation in a separate matplotlib window 
if so requested via the boolean flags \verb|plot_tour_p| , and \verb|animate_tour_p|. If both 
animation and plotting are requested they are done in separate windows each. 

%{python-mode}%
\begin{flushleft} \small\label{scrap1}\raggedright\small
\NWtarget{nuweb6}{} $\langle\,${\itshape PHO Data Structures}\nobreak\ {\footnotesize {6}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@@\\
\mbox{}\verb@class Single_PHO_Input:@\\
\mbox{}\verb@    def __init__(self, drone_info = [] , source = None, target=None):@\\
\mbox{}\verb@           self.drone_info = drone_info @\\
\mbox{}\verb@           self.source     = source@\\
\mbox{}\verb@           self.target     = target@\\
\mbox{}\verb@@\\
\mbox{}\verb@    def get_drone_pis (self):@\\
\mbox{}\verb@           return [self.drone_info[idx][0] for idx in range(len(self.drone_info)) ]@\\
\mbox{}\verb@           @\\
\mbox{}\verb@    def get_drone_uis (self):@\\
\mbox{}\verb@           return [self.drone_info[idx][1] for idx in range(len(self.drone_info)) ]@\\
\mbox{}\verb@         @\\
\mbox{}\verb@    def get_tour(self, algo):@\\
\mbox{}\verb@           return algo( self.drone_info, self.source, self.target, @\\
\mbox{}\verb@                        animate_tour_p = True,@\\
\mbox{}\verb@                        plot_tour_p    = False)@\\
\mbox{}\verb@@\\
\mbox{}\verb@    # Methods for \verb|ReverseHorseflyInput|@\\
\mbox{}\verb@    def clearAllStates (self):@\\
\mbox{}\verb@          self.drone_info = []@\\
\mbox{}\verb@          self.source = None@\\
\mbox{}\verb@          self.target = None@\\
\mbox{}\verb@@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb20}{20}.
\item \NWtxtIdentsDefed\nobreak\  \verb@Single_PHO_Input@\nobreak\ \NWlink{nuweb15}{15}.
\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
%{/python-mode}%

\subsection{One-Dimensional Greedy Wavefront} \hspace{10mm}


\begin{figure}[H]
\centering
\includegraphics[width=14cm]{images/circular_wavelets_intersect_along_st.pdf}
\caption{Intersection of two expanding wavelets along $\vec{S_iT}$}
\end{figure}

The following function calculates the time taken for a drone to move between two points at a given uniform speed
 


%{python-mode}%
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap2}\raggedright\small
\NWtarget{nuweb7a}{} $\langle\,${\itshape PHO Algorithms}\nobreak\ {\footnotesize {7a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@@\\
\mbox{}\verb@def time_of_travel(start, stop, speed):@\\
\mbox{}\verb@     start = np.asarray(start)@\\
\mbox{}\verb@     stop  = np.asarray(stop)@\\
\mbox{}\verb@     return np.linalg.norm(stop-start)/speed@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb7a}{7a}\NWlink{nuweb7b}{b}\NWlink{nuweb10}{, 10}\NWlink{nuweb11}{, 11}\NWlink{nuweb13}{, 13}\NWlink{nuweb14}{, 14}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb20}{20}.
\item \NWtxtIdentsDefed\nobreak\  \verb@time_of_travel@\nobreak\ \NWlink{nuweb7b}{7b}\NWlink{nuweb14}{, 14}.
\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
%{/python-mode}%



%{python-mode}%
\begin{flushleft} \small\label{scrap3}\raggedright\small
\NWtarget{nuweb7b}{} $\langle\,${\itshape PHO Algorithms}\nobreak\ {\footnotesize {7b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@@\\
\mbox{}\verb@def algo_odw(drone_info, source, target, @\\
\mbox{}\verb@             animate_tour_p = False,@\\
\mbox{}\verb@             plot_tour_p    = False):@\\
\mbox{}\verb@@\\
\mbox{}\verb@    from scipy.optimize import minimize@\\
\mbox{}\verb@@\\
\mbox{}\verb@    source = np.asarray(source)@\\
\mbox{}\verb@    target = np.asarray(target)@\\
\mbox{}\verb@    sthat  = (target-source)/np.linalg.norm(target-source) # unit vector pointing from source to target@\\
\mbox{}\verb@@\\
\mbox{}\verb@    numdrones  = len(drone_info)@\\
\mbox{}\verb@    clock_time = 0.0@\\
\mbox{}\verb@@\\
\mbox{}\verb@    # Find the drone which can get to the source the quickest@\\
\mbox{}\verb@    tmin = np.inf@\\
\mbox{}\verb@    imin = None@\\
\mbox{}\verb@    for idx in range(numdrones):@\\
\mbox{}\verb@         initdroneposn = drone_info[idx][0]@\\
\mbox{}\verb@         dronespeed    = drone_info[idx][1]@\\
\mbox{}\verb@         tmin_idx = time_of_travel(initdroneposn, source, dronespeed)@\\
\mbox{}\verb@@\\
\mbox{}\verb@         if tmin_idx < tmin:@\\
\mbox{}\verb@             tmin = tmin_idx@\\
\mbox{}\verb@             imin = idx @\\
\mbox{}\verb@@\\
\mbox{}\verb@    clock_time = tmin@\\
\mbox{}\verb@@\\
\mbox{}\verb@    current_package_handler_idx = imin@\\
\mbox{}\verb@    current_package_position    = source@\\
\mbox{}\verb@@\\
\mbox{}\verb@    drone_pool = range(numdrones)@\\
\mbox{}\verb@    drone_pool.remove(imin) @\\
\mbox{}\verb@    used_drones = [imin]@\\
\mbox{}\verb@@\\
\mbox{}\verb@    package_trail = [current_package_position]@\\
\mbox{}\verb@@\\
\mbox{}\verb@    package_reached_p   = False@\\
\mbox{}\verb@    while not(package_reached_p):@\\
\mbox{}\verb@@\\
\mbox{}\verb@          time_to_target_without_help =\@\\
\mbox{}\verb@              np.linalg.norm((target-current_package_position))/drone_info[current_package_handler_idx][1]@\\
\mbox{}\verb@@\\
\mbox{}\verb@          tI_min     = np.inf@\\
\mbox{}\verb@          idx_tI_min = None@\\
\mbox{}\verb@          for idx in drone_pool:@\\
\mbox{}\verb@              @\\
\mbox{}\verb@              us = drone_info[current_package_handler_idx][1]@\\
\mbox{}\verb@              up = drone_info[idx][1]@\\
\mbox{}\verb@@\\
\mbox{}\verb@              if up <= us: # slower drones are useless, so skip rest of the iteration@\\
\mbox{}\verb@                  continue @\\
\mbox{}\verb@              else: @\\
\mbox{}\verb@                s = current_package_position @\\
\mbox{}\verb@                p = np.asarray(drone_info[idx][0]) @\\
\mbox{}\verb@@\\
\mbox{}\verb@                tI = get_interception_time(s, us, p, up, target, clock_time)@\\
\mbox{}\verb@@\\
\mbox{}\verb@                if tI < tI_min:@\\
\mbox{}\verb@                   tI_min     = tI@\\
\mbox{}\verb@                   idx_tI_min = idx@\\
\mbox{}\verb@@\\
\mbox{}\verb@          if time_to_target_without_help < tI_min :@\\
\mbox{}\verb@              package_reached_p = True@\\
\mbox{}\verb@              package_trail.append(target)@\\
\mbox{}\verb@@\\
\mbox{}\verb@          else:@\\
\mbox{}\verb@              package_handler_speed    = drone_info[current_package_handler_idx][1] @\\
\mbox{}\verb@              current_package_position = current_package_position + package_handler_speed * (tI_min - clock_time) *  sthat@\\
\mbox{}\verb@              package_trail.append(current_package_position)@\\
\mbox{}\verb@    @\\
\mbox{}\verb@              clock_time                  = tI_min @\\
\mbox{}\verb@              current_package_handler_idx = idx_tI_min@\\
\mbox{}\verb@@\\
\mbox{}\verb@              drone_pool.remove(idx_tI_min)@\\
\mbox{}\verb@              used_drones.append(idx_tI_min)  @\\
\mbox{}\verb@   @\\
\mbox{}\verb@    package_trail_cvx = algo_pho_exact_given_order_of_drones ([drone_info[idx] for idx in used_drones],source,target )@\\
\mbox{}\verb@    mspan_straight = makespan(drone_info, used_drones, package_trail)@\\
\mbox{}\verb@    mspan_cvx      = makespan(drone_info, used_drones, package_trail_cvx)@\\
\mbox{}\verb@    @\\
\mbox{}\verb@    #assert (mspan_cvx <= mspan_straight), ""@\\
\mbox{}\verb@@\\
\mbox{}\verb@    if plot_tour_p:@\\
\mbox{}\verb@         fig0, ax0 = plt.subplots()@\\
\mbox{}\verb@         plot_tour(fig0, ax0, "ODW: Straight Line"       , source, target, drone_info, used_drones, package_trail)@\\
\mbox{}\verb@@\\
\mbox{}\verb@         fig1, ax1 = plt.subplots()@\\
\mbox{}\verb@         plot_tour(fig1, ax1, "ODE: Straight Line, Post Convex Optimization", source, target, drone_info, used_drones, package_trail_cvx)@\\
\mbox{}\verb@         plt.show()@\\
\mbox{}\verb@@\\
\mbox{}\verb@    if animate_tour_p:@\\
\mbox{}\verb@@\\
\mbox{}\verb@        #ptraj  = zip(package_trail_cvx, used_drones + [None])@\\
\mbox{}\verb@        animate_tour(drone_info, [package_trail] , used_drones,@\\
\mbox{}\verb@                     animation_file_name_prefix='package_handoff_animation.mp4', @\\
\mbox{}\verb@                     algo_name='odw',  @\\
\mbox{}\verb@                     render_trajectory_trails_p=True) @\\
\mbox{}\verb@    @\\
\mbox{}\verb@    return used_drones, package_trail, mspan_straight, mspan_cvx, @\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb7a}{7a}\NWlink{nuweb7b}{b}\NWlink{nuweb10}{, 10}\NWlink{nuweb11}{, 11}\NWlink{nuweb13}{, 13}\NWlink{nuweb14}{, 14}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb20}{20}.
\item \NWtxtIdentsDefed\nobreak\  \verb@algo_odw@\nobreak\ \NWlink{nuweb15}{15}.\item \NWtxtIdentsUsed\nobreak\  \verb@time_of_travel@\nobreak\ \NWlink{nuweb7a}{7a}.
\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
%{/python-mode}%

 

%{python-mode}%
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap4}\raggedright\small
\NWtarget{nuweb10}{} $\langle\,${\itshape PHO Algorithms}\nobreak\ {\footnotesize {10}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@def extract_coordinates(points):@\\
\mbox{}\verb@@\\
\mbox{}\verb@    xs, ys = [], []@\\
\mbox{}\verb@    for pt in points:@\\
\mbox{}\verb@        xs.append(pt[0])@\\
\mbox{}\verb@        ys.append(pt[1])@\\
\mbox{}\verb@    return np.asarray(xs), np.asarray(ys)@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@def get_interception_time(s, us, p, up, t, t0) :@\\
\mbox{}\verb@    @\\
\mbox{}\verb@    t_m = t - s # the _m subscript stands for modify@\\
\mbox{}\verb@    t_m /= np.linalg.norm(t_m) # normalize to unit@\\
\mbox{}\verb@@\\
\mbox{}\verb@    # For rotating a vector clockwise by theta, @\\
\mbox{}\verb@    # to get the vector t_m into alignment with (1,0)@\\
\mbox{}\verb@    costh = t_m[0]/np.sqrt(t_m[0]**2 + t_m[1]**2)@\\
\mbox{}\verb@    sinth = t_m[1]/np.sqrt(t_m[0]**2 + t_m[1]**2)@\\
\mbox{}\verb@@\\
\mbox{}\verb@    rotmat = np.asarray([[costh, sinth],@\\
\mbox{}\verb@                         [-sinth, costh]])@\\
\mbox{}\verb@    @\\
\mbox{}\verb@    assert np.linalg.norm((rotmat.dot(t_m) - np.asarray([1,0]))) <= 1e-6,\@\\
\mbox{}\verb@           "Rotation matrix did not work properly. t_m should get rotated onto [1,0] after this transformation"@\\
\mbox{}\verb@@\\
\mbox{}\verb@    p_shift  = p - s@\\
\mbox{}\verb@    p_rot    = rotmat.dot(p_shift)@\\
\mbox{}\verb@    [alpha, beta] = p_rot@\\
\mbox{}\verb@@\\
\mbox{}\verb@    # Solve quadratic documented in the snippets above@\\
\mbox{}\verb@    qroots = np.roots([ (1.0/us**2 - 1.0/up**2), @\\
\mbox{}\verb@               2*t0/us + 2*alpha/up**2 , @\\
\mbox{}\verb@               t0**2 - alpha**2/up**2 - beta**2/up**2])@\\
\mbox{}\verb@@\\
\mbox{}\verb@    # The quadratic should always a root. @\\
\mbox{}\verb@    qroots = np.real(qroots) # in case the imaginary parts of the roots are really small, @\\
\mbox{}\verb@    qroots.sort()@\\
\mbox{}\verb@@\\
\mbox{}\verb@    x = None@\\
\mbox{}\verb@    for root in qroots:@\\
\mbox{}\verb@        if root > 0.0:@\\
\mbox{}\verb@           x = root@\\
\mbox{}\verb@           break@\\
\mbox{}\verb@    assert abs(x/us+t0 - np.sqrt((x-alpha)**2 + beta**2)/up) <= 1e-6 , "Quadratic not solved perfectly"@\\
\mbox{}\verb@@\\
\mbox{}\verb@    tI = x/us + t0@\\
\mbox{}\verb@    return tI@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb7a}{7a}\NWlink{nuweb7b}{b}\NWlink{nuweb10}{, 10}\NWlink{nuweb11}{, 11}\NWlink{nuweb13}{, 13}\NWlink{nuweb14}{, 14}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb20}{20}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
%{/python-mode}%

When the drones involved in the package handoff process, along with the order of handoff is known in advance, 
we can find the handoff points exactly using convex optimization using SOCP. 

\section{Handoff in a particular order}

\begin{figure}[H]
\centering
\includegraphics[width=10cm]{images/pho-cvx.pdf}
\end{figure}


Given drones $P_i$, with speeds $u_i$ $1 \leq i \leq r-1$, the intial position $S$ and final destination $T$ for the package. 
The drones are expected to transport the package by handing of the package in the order $1,2,\ldots, r$.
Let $t_i$ denote the departure time on a global clock from the $i$'th handoff point $X_i$. 

Then the minimum time for transporting the package and the handoff points can be calculated according to the following 
convex program 


\noindent\fbox{%
    \parbox{\textwidth}{%

\begin{equation*}
\min_{t_i, X_i} \; \; \; t_{r-1} + \frac{||T-X_{r-1}||}{u_{r-1}}
\end{equation*}

subject to the constraints

\begin{align*}
X_0 &= S\\  
t_i &\geq \frac{||P_i-X_i||}{u_i} \qquad \qquad 0 \leq i \leq r-1\\
t_i + \frac{||X_{i+1}-X_i||}{u_i} &\leq t_{i+1} \qquad \qquad \qquad \;\;\;\; 0 \leq i \leq r-2
\end{align*}

    }%
}


The following function is just an implentation of the program above. 

%{python-mode}%
\begin{flushleft} \small\label{scrap5}\raggedright\small
\NWtarget{nuweb11}{} $\langle\,${\itshape PHO Algorithms}\nobreak\ {\footnotesize {11}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@@\\
\mbox{}\verb@def algo_pho_exact_given_order_of_drones ( drone_info, source, target ):@\\
\mbox{}\verb@    import cvxpy as cp@\\
\mbox{}\verb@@\\
\mbox{}\verb@    source = np.asarray(source)@\\
\mbox{}\verb@    target = np.asarray(target)@\\
\mbox{}\verb@@\\
\mbox{}\verb@    r = len(drone_info) @\\
\mbox{}\verb@    source = np.asarray(source)@\\
\mbox{}\verb@    target = np.asarray(target)@\\
\mbox{}\verb@    @\\
\mbox{}\verb@    # Variables for rendezvous points of robot with package@\\
\mbox{}\verb@    X, t = [], []@\\
\mbox{}\verb@    for i in range(r):@\\
\mbox{}\verb@       X.append(cp.Variable(2)) # vector variable@\\
\mbox{}\verb@       t.append(cp.Variable( )) # scalar variable@\\
\mbox{}\verb@@\\
\mbox{}\verb@    # Constraints @\\
\mbox{}\verb@    constraints_S = [  X[0] == source ]@\\
\mbox{}\verb@@\\
\mbox{}\verb@    constraints_I = [] @\\
\mbox{}\verb@    for i in range(r):@\\
\mbox{}\verb@        constraints_I.append( 0.0 <= t[i] )@\\
\mbox{}\verb@        constraints_I.append( t[i] >= cp.norm( np.asarray(drone_info[i][0]) - X[i]) / drone_info[i][1] )@\\
\mbox{}\verb@@\\
\mbox{}\verb@    constraints_L = []@\\
\mbox{}\verb@    for i in range(r-1):@\\
\mbox{}\verb@         constraints_L.append( t[i] + cp.norm(X[i+1] - X[i])/drone_info[i][1] <= t[i+1] )@\\
\mbox{}\verb@@\\
\mbox{}\verb@    objective = cp.Minimize(  t[r-1]  + cp.norm( target - X[r-1]  )/drone_info[r-1][1]  )@\\
\mbox{}\verb@@\\
\mbox{}\verb@    prob = cp.Problem(objective, constraints_S + constraints_I + constraints_L)@\\
\mbox{}\verb@    print Fore.CYAN@\\
\mbox{}\verb@    prob.solve(solver=cp.SCS, verbose=True)@\\
\mbox{}\verb@    print Style.RESET_ALL@\\
\mbox{}\verb@    @\\
\mbox{}\verb@    package_trail = [ np.asarray(X[i].value) for i in range(r) ] + [ target ]@\\
\mbox{}\verb@    return package_trail@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb7a}{7a}\NWlink{nuweb7b}{b}\NWlink{nuweb10}{, 10}\NWlink{nuweb11}{, 11}\NWlink{nuweb13}{, 13}\NWlink{nuweb14}{, 14}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb20}{20}.

\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
%{/python-mode}%

\section{Plotting}

We plot the tours onto a separate window if the switch \verb|plot_tour_p| is set to \verb|True| 
while calling the algorithm. The path of the package is shown in bold red. The paths of the drones 
from their initial positions to the point where they pick up the package from another drone 
are shown in blue.

An example is shown below: 



\begin{figure}[H]
\centering
\includegraphics[width=8cm]{images/pho_example_plot.pdf}
\end{figure}


%{python-mode}%
\begin{flushleft} \small\label{scrap6}\raggedright\small
\NWtarget{nuweb13}{} $\langle\,${\itshape PHO Algorithms}\nobreak\ {\footnotesize {13}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@def plot_tour(fig, ax, figtitle, source, target, drone_info, used_drones, package_trail):@\\
\mbox{}\verb@@\\
\mbox{}\verb@    ax.set_aspect(1.0)@\\
\mbox{}\verb@    ax.set_xlim([0.0, 1.0])@\\
\mbox{}\verb@    ax.set_ylim([0.0, 1.0])@\\
\mbox{}\verb@@\\
\mbox{}\verb@    # Draw drone path from initial position to interception point@\\
\mbox{}\verb@    for pt, idx in zip(package_trail, used_drones):@\\
\mbox{}\verb@         initdroneposn = drone_info[idx][0]@\\
\mbox{}\verb@         handoffpoint  = pt@\\
\mbox{}\verb@    @\\
\mbox{}\verb@         xs, ys = extract_coordinates([initdroneposn, handoffpoint])@\\
\mbox{}\verb@         plt.arrow( xs[0], ys[0], xs[1]-xs[0], ys[1]-ys[0], @\\
\mbox{}\verb@                    **{'length_includes_head': True, @\\
\mbox{}\verb@                       'width': 0.005 , @\\
\mbox{}\verb@                       'head_width':0.02, @\\
\mbox{}\verb@                       'fc': 'b', @\\
\mbox{}\verb@                       'ec': 'none'})@\\
\mbox{}\verb@@\\
\mbox{}\verb@    # Draw the package trail@\\
\mbox{}\verb@    xs, ys = extract_coordinates(package_trail)@\\
\mbox{}\verb@    ax.plot(xs,ys, 'ro', markersize=5 )@\\
\mbox{}\verb@    for idx in range(len(xs)-1):@\\
\mbox{}\verb@          plt.arrow( xs[idx], ys[idx], xs[idx+1]-xs[idx], ys[idx+1]-ys[idx], @\\
\mbox{}\verb@                    **{'length_includes_head': True, @\\
\mbox{}\verb@                       'width': 0.007 , @\\
\mbox{}\verb@                       'head_width':0.03, @\\
\mbox{}\verb@                       'fc': 'r', @\\
\mbox{}\verb@                       'ec': 'none',@\\
\mbox{}\verb@                       'alpha': 0.8})@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@    # Draw the source, target, and initial positions of the robots as bold dots@\\
\mbox{}\verb@    xs,ys = extract_coordinates([source, target])@\\
\mbox{}\verb@    ax.plot(xs,ys, 'o', markersize=30, alpha=0.8, ms=10, mec='k', mfc='#F1AB30' )@\\
\mbox{}\verb@    ax.plot(xs,ys, 'k--', alpha=0.6 ) # light line connecting source and target@\\
\mbox{}\verb@@\\
\mbox{}\verb@    ax.text(source[0], source[1], 'S', fontsize=22,\@\\
\mbox{}\verb@            horizontalalignment='center',verticalalignment='center')@\\
\mbox{}\verb@    ax.text(target[0], target[1], 'T', fontsize=22,\@\\
\mbox{}\verb@            horizontalalignment='center',verticalalignment='center')@\\
\mbox{}\verb@@\\
\mbox{}\verb@    xs, ys = extract_coordinates( [ drone_info[idx][0] for idx in range(len(drone_info)) ]  )@\\
\mbox{}\verb@    ax.plot(xs,ys, 'o', markersize=26, mec='k', mfc='#b7e8cc' )@\\
\mbox{}\verb@@\\
\mbox{}\verb@    # Draw speed labels@\\
\mbox{}\verb@    for idx in range(len(drone_info)):@\\
\mbox{}\verb@         ax.text( drone_info[idx][0][0], drone_info[idx][0][1], drone_info[idx][1],@\\
\mbox{}\verb@                  fontsize=15, horizontalalignment='center', verticalalignment='center' )@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@    fig.suptitle(figtitle, fontsize=25)@\\
\mbox{}\verb@    ax.set_title('\nMakespan: ' + format(makespan(drone_info, used_drones, package_trail),'.5f'), fontsize=15)@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@    # A light grid@\\
\mbox{}\verb@    plt.grid(color='0.5', linestyle='--', linewidth=0.5)@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb7a}{7a}\NWlink{nuweb7b}{b}\NWlink{nuweb10}{, 10}\NWlink{nuweb11}{, 11}\NWlink{nuweb13}{, 13}\NWlink{nuweb14}{, 14}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb20}{20}.

\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
%{/python-mode}%


By makespan, we mean the time taken for the package to travel from $S$ to $T$.


%{python-mode}%
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap7}\raggedright\small
\NWtarget{nuweb14}{} $\langle\,${\itshape PHO Algorithms}\nobreak\ {\footnotesize {14}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@@\\
\mbox{}\verb@def makespan(drone_info, used_drones, package_trail):@\\
\mbox{}\verb@@\\
\mbox{}\verb@    assert len(package_trail) == len(used_drones)+1, ""@\\
\mbox{}\verb@@\\
\mbox{}\verb@    makespan = 0.0   @\\
\mbox{}\verb@    counter  = 0    @\\
\mbox{}\verb@    for idx in used_drones:@\\
\mbox{}\verb@         dronespeed    = drone_info[idx][1]          @\\
\mbox{}\verb@@\\
\mbox{}\verb@         makespan += time_of_travel(package_trail[counter],\@\\
\mbox{}\verb@                                    package_trail[counter+1],@\\
\mbox{}\verb@                                    dronespeed) @\\
\mbox{}\verb@         counter += 1@\\
\mbox{}\verb@    @\\
\mbox{}\verb@    return makespan@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb7a}{7a}\NWlink{nuweb7b}{b}\NWlink{nuweb10}{, 10}\NWlink{nuweb11}{, 11}\NWlink{nuweb13}{, 13}\NWlink{nuweb14}{, 14}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb20}{20}.
\item \NWtxtIdentsUsed\nobreak\  \verb@time_of_travel@\nobreak\ \NWlink{nuweb7a}{7a}.
\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
%{/python-mode}%
  




\newpage
\section{Run Handler associated with this Chapter}


%{python-mode}%
\begin{flushleft} \small\label{scrap8}\raggedright\small
\NWtarget{nuweb15}{} $\langle\,${\itshape PHO Run Handlers}\nobreak\ {\footnotesize {15}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@@\\
\mbox{}\verb@def single_pho_run_handler():@\\
\mbox{}\verb@    import random@\\
\mbox{}\verb@    def wrapperEnterRunPoints(fig, ax, run):@\\
\mbox{}\verb@      def _enterPoints(event):@\\
\mbox{}\verb@        if event.name      == 'button_press_event'          and \@\\
\mbox{}\verb@           (event.button   == 1 or event.button == 3)       and \@\\
\mbox{}\verb@            event.dblclick == True and event.xdata  != None and event.ydata  != None:@\\
\mbox{}\verb@@\\
\mbox{}\verb@             if event.button == 1:  @\\
\mbox{}\verb@                 # Insert blue circle representing the initial position of a drone@\\
\mbox{}\verb@                 print Fore.GREEN@\\
\mbox{}\verb@                 newPoint = (event.xdata, event.ydata)@\\
\mbox{}\verb@                 speed    = float(raw_input('What speed do you want for the drone at '+str(newPoint)))@\\
\mbox{}\verb@                 run.drone_info.append( (newPoint, speed) ) @\\
\mbox{}\verb@                 patchSize  = (xlim[1]-xlim[0])/40.0@\\
\mbox{}\verb@                 print Style.RESET_ALL@\\
\mbox{}\verb@                 @\\
\mbox{}\verb@                 ax.add_patch( mpl.patches.Circle( newPoint, radius = patchSize,@\\
\mbox{}\verb@                                                   facecolor='#b7e8cc', edgecolor='black'  ))@\\
\mbox{}\verb@@\\
\mbox{}\verb@                 ax.text( newPoint[0], newPoint[1], speed, fontsize=15, @\\
\mbox{}\verb@                          horizontalalignment='center', verticalalignment='center' )@\\
\mbox{}\verb@@\\
\mbox{}\verb@                 ax.set_title('Number of drones inserted: ' +\@\\
\mbox{}\verb@                              str(len(run.drone_info)), fontdict={'fontsize':25})@\\
\mbox{}\verb@                 @\\
\mbox{}\verb@             elif event.button == 3:  @\\
\mbox{}\verb@                 # Insert big red circles representing the source and target points@\\
\mbox{}\verb@                 patchSize  = (xlim[1]-xlim[0])/50.0@\\
\mbox{}\verb@                 if run.source is None:    @\\
\mbox{}\verb@                      run.source = (event.xdata, event.ydata)  @\\
\mbox{}\verb@                      ax.add_patch( mpl.patches.Circle( run.source, radius = patchSize, @\\
\mbox{}\verb@                                                        facecolor= '#ffd9d6', edgecolor='black', lw=1.0 ))@\\
\mbox{}\verb@                      ax.text( run.source[0], run.source[1], 'S', fontsize=15, @\\
\mbox{}\verb@                               horizontalalignment='center', verticalalignment='center' )@\\
\mbox{}\verb@@\\
\mbox{}\verb@                 elif run.target is None:@\\
\mbox{}\verb@                      run.target = (event.xdata, event.ydata)  @\\
\mbox{}\verb@                      ax.add_patch( mpl.patches.Circle( run.target, radius = patchSize, @\\
\mbox{}\verb@                                                       facecolor= '#ffd9d6', edgecolor='black', lw=1.0 ))@\\
\mbox{}\verb@                      ax.text( run.target[0], run.target[1], 'T', fontsize=15, @\\
\mbox{}\verb@                               horizontalalignment='center', verticalalignment='center' )@\\
\mbox{}\verb@                 else:@\\
\mbox{}\verb@                       print Fore.RED, "Source and Target already set", Style.RESET_ALL@\\
\mbox{}\verb@             # Clear polygon patches and set up last minute \verb|ax| tweaks@\\
\mbox{}\verb@             clearAxPolygonPatches(ax)@\\
\mbox{}\verb@             applyAxCorrection(ax)@\\
\mbox{}\verb@             fig.canvas.draw()@\\
\mbox{}\verb@      return _enterPoints@\\
\mbox{}\verb@@\\
\mbox{}\verb@    # The key-stack argument is mutable! I am using this hack to my advantage.@\\
\mbox{}\verb@    def wrapperkeyPressHandler(fig, ax, run): @\\
\mbox{}\verb@           def _keyPressHandler(event):@\\
\mbox{}\verb@               if event.key in ['i', 'I']:  @\\
\mbox{}\verb@@\\
\mbox{}\verb@                    # Select algorithm to execute@\\
\mbox{}\verb@                    algo_str = raw_input(Fore.YELLOW                                             +\@\\
\mbox{}\verb@                            "Enter algorithm to be used to compute the tour:\n Options are:\n"   +\@\\
\mbox{}\verb@                            " (odw)     One Dimensional Wavefront \n"                            +\@\\
\mbox{}\verb@                            Style.RESET_ALL)@\\
\mbox{}\verb@@\\
\mbox{}\verb@                    algo_str = algo_str.lstrip()@\\
\mbox{}\verb@                     @\\
\mbox{}\verb@                    # Incase there are patches present from the previous clustering, just clear them@\\
\mbox{}\verb@                    clearAxPolygonPatches(ax)@\\
\mbox{}\verb@                    if   algo_str == 'odw':@\\
\mbox{}\verb@                          tour = run.get_tour( algo_odw )@\\
\mbox{}\verb@                    else:@\\
\mbox{}\verb@                          print "Unknown option. No horsefly for you! ;-D "@\\
\mbox{}\verb@                          sys.exit()@\\
\mbox{}\verb@                    applyAxCorrection(ax)@\\
\mbox{}\verb@                    fig.canvas.draw()@\\
\mbox{}\verb@                    @\\
\mbox{}\verb@               elif event.key in ['c', 'C']: @\\
\mbox{}\verb@                    # Clear canvas and states of all objects@\\
\mbox{}\verb@                    run.clearAllStates()@\\
\mbox{}\verb@                    ax.cla()@\\
\mbox{}\verb@                                  @\\
\mbox{}\verb@                    applyAxCorrection(ax)@\\
\mbox{}\verb@                    ax.set_xticks([])@\\
\mbox{}\verb@                    ax.set_yticks([])@\\
\mbox{}\verb@                                     @\\
\mbox{}\verb@                    fig.texts = []@\\
\mbox{}\verb@                    fig.canvas.draw()@\\
\mbox{}\verb@           return _keyPressHandler@\\
\mbox{}\verb@    @\\
\mbox{}\verb@    # Set up interactive canvas@\\
\mbox{}\verb@    fig, ax =  plt.subplots()@\\
\mbox{}\verb@    run = Single_PHO_Input()@\\
\mbox{}\verb@        @\\
\mbox{}\verb@    from matplotlib import rc@\\
\mbox{}\verb@    @\\
\mbox{}\verb@    # specify the custom font to use@\\
\mbox{}\verb@    plt.rcParams['font.family'] = 'sans-serif'@\\
\mbox{}\verb@    plt.rcParams['font.sans-serif'] = 'Times New Roman'@\\
\mbox{}\verb@@\\
\mbox{}\verb@    ax.set_xlim([xlim[0], xlim[1]])@\\
\mbox{}\verb@    ax.set_ylim([ylim[0], ylim[1]])@\\
\mbox{}\verb@    ax.set_aspect(1.0)@\\
\mbox{}\verb@    ax.set_xticks([])@\\
\mbox{}\verb@    ax.set_yticks([])@\\
\mbox{}\verb@          @\\
\mbox{}\verb@    ax.set_title("Enter drone positions, source and target onto canvas. \n \@\\
\mbox{}\verb@(Enter speeds into the terminal, after inserting a drone at a particular position)")@\\
\mbox{}\verb@@\\
\mbox{}\verb@    mouseClick   = wrapperEnterRunPoints (fig,ax, run)@\\
\mbox{}\verb@    fig.canvas.mpl_connect('button_press_event' , mouseClick)@\\
\mbox{}\verb@          @\\
\mbox{}\verb@    keyPress     = wrapperkeyPressHandler(fig,ax, run)@\\
\mbox{}\verb@    fig.canvas.mpl_connect('key_press_event', keyPress   )@\\
\mbox{}\verb@    @\\
\mbox{}\verb@    plt.show()@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb20}{20}.
\item \NWtxtIdentsDefed\nobreak\  \verb@single_pho_run_handler@\nobreak\ \NWlink{nuweb20}{20}.\item \NWtxtIdentsUsed\nobreak\  \verb@algo_odw@\nobreak\ \NWlink{nuweb7b}{7b}, \verb@Single_PHO_Input@\nobreak\ \NWlink{nuweb6}{6}.
\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
%{/python-mode}%




\section{Chapter Index of Fragments}

{\small\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item $\langle\,$PHO Algorithms\nobreak\ {\footnotesize \NWlink{nuweb7a}{7a}\NWlink{nuweb7b}{b}\NWlink{nuweb10}{, 10}\NWlink{nuweb11}{, 11}\NWlink{nuweb13}{, 13}\NWlink{nuweb14}{, 14}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb20}{20}.}
\item $\langle\,$PHO Data Structures\nobreak\ {\footnotesize \NWlink{nuweb6}{6}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb20}{20}.}
\item $\langle\,$PHO Run Handlers\nobreak\ {\footnotesize \NWlink{nuweb15}{15}}$\,\rangle$ {\footnotesize {\NWtxtRefIn} \NWlink{nuweb20}{20}.}
\end{list}}
\section{Chapter Index of Identifiers}

{\small\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \verb@algo_odw@: \underline{\NWlink{nuweb7b}{7b}}\NWlink{nuweb15}{, 15}.
\item \verb@Single_PHO_Input@: \underline{\NWlink{nuweb6}{6}}\NWlink{nuweb15}{, 15}.
\item \verb@single_pho_run_handler@: \underline{\NWlink{nuweb15}{15}}\NWlink{nuweb20}{, 20}.
\item \verb@time_of_travel@: \underline{\NWlink{nuweb7a}{7a}}\NWlink{nuweb7b}{, 7b}\NWlink{nuweb14}{, 14}.
\end{list}} 
%------------------------------------------------------
\nocite{*} % include everything in the bibtex file
\bibliography{packagehandoff-main} 
\bibliographystyle{ieeetr}

\begin{appendices}
\chapter{Supporting Code}

\section{Main File}



%{python-mode}%
\begin{flushleft} \small\label{scrap9}\raggedright\small
\NWtarget{nuweb20}{} \verb@"../src/pho-main.py"@\nobreak\ {\footnotesize {20}}$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@@\\
\mbox{}\verb@# Relevant imports for Package Handoff@\\
\mbox{}\verb@@\\
\mbox{}\verb@from colorama import Fore, Style@\\
\mbox{}\verb@from matplotlib import rc@\\
\mbox{}\verb@from scipy.optimize import minimize@\\
\mbox{}\verb@from sklearn.cluster import KMeans@\\
\mbox{}\verb@import argparse@\\
\mbox{}\verb@import inspect @\\
\mbox{}\verb@import itertools@\\
\mbox{}\verb@import logging@\\
\mbox{}\verb@import math@\\
\mbox{}\verb@import matplotlib as mpl@\\
\mbox{}\verb@import matplotlib.pyplot as plt@\\
\mbox{}\verb@import numpy as np@\\
\mbox{}\verb@import os@\\
\mbox{}\verb@import pprint as pp@\\
\mbox{}\verb@import randomcolor @\\
\mbox{}\verb@import sys@\\
\mbox{}\verb@import time@\\
\mbox{}\verb@import utils_algo@\\
\mbox{}\verb@import utils_graphics@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,${\itshape PHO Data Structures}\nobreak\ {\footnotesize \NWlink{nuweb6}{6}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,${\itshape PHO Algorithms}\nobreak\ {\footnotesize \NWlink{nuweb7a}{7a}, \ldots\ }$\,\rangle$}\verb@@\\
\mbox{}\verb@@\hbox{$\langle\,${\itshape PHO Run Handlers}\nobreak\ {\footnotesize \NWlink{nuweb15}{15}}$\,\rangle$}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@# Set up logging information relevant to this module@\\
\mbox{}\verb@logger=logging.getLogger(__name__)@\\
\mbox{}\verb@logging.basicConfig(level=logging.DEBUG)@\\
\mbox{}\verb@@\\
\mbox{}\verb@def debug(msg):@\\
\mbox{}\verb@    frame,filename,line_number,function_name,lines,index=inspect.getouterframes(@\\
\mbox{}\verb@        inspect.currentframe())[1]@\\
\mbox{}\verb@    line=lines[0]@\\
\mbox{}\verb@    indentation_level=line.find(line.lstrip())@\\
\mbox{}\verb@    logger.debug('{i} [{m}]'.format(@\\
\mbox{}\verb@        i='.'*indentation_level, m=msg))@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@def info(msg):@\\
\mbox{}\verb@    frame,filename,line_number,function_name,lines,index=inspect.getouterframes(@\\
\mbox{}\verb@        inspect.currentframe())[1]@\\
\mbox{}\verb@    line=lines[0]@\\
\mbox{}\verb@    indentation_level=line.find(line.lstrip())@\\
\mbox{}\verb@    logger.info('{i} [{m}]'.format(@\\
\mbox{}\verb@        i='.'*indentation_level, m=msg))@\\
\mbox{}\verb@@\\
\mbox{}\verb@xlim, ylim = [0,1], [0,1]@\\
\mbox{}\verb@@\\
\mbox{}\verb@def applyAxCorrection(ax):@\\
\mbox{}\verb@      ax.set_xlim([xlim[0], xlim[1]])@\\
\mbox{}\verb@      ax.set_ylim([ylim[0], ylim[1]])@\\
\mbox{}\verb@      ax.set_aspect(1.0)@\\
\mbox{}\verb@@\\
\mbox{}\verb@def clearPatches(ax):@\\
\mbox{}\verb@    # Get indices cooresponding to the polygon patches@\\
\mbox{}\verb@    for index , patch in zip(range(len(ax.patches)), ax.patches):@\\
\mbox{}\verb@        if isinstance(patch, mpl.patches.Polygon) == True:@\\
\mbox{}\verb@            patch.remove()@\\
\mbox{}\verb@    ax.lines[:]=[]@\\
\mbox{}\verb@    applyAxCorrection(ax)@\\
\mbox{}\verb@@\\
\mbox{}\verb@def clearAxPolygonPatches(ax):@\\
\mbox{}\verb@@\\
\mbox{}\verb@    # Get indices cooresponding to the polygon patches@\\
\mbox{}\verb@    for index , patch in zip(range(len(ax.patches)), ax.patches):@\\
\mbox{}\verb@        if isinstance(patch, mpl.patches.Polygon) == True:@\\
\mbox{}\verb@            patch.remove()@\\
\mbox{}\verb@    ax.lines[:]=[]@\\
\mbox{}\verb@    applyAxCorrection(ax)@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@# A drone trajectory is [ idx,      ]@\\
\mbox{}\verb@def animate_tour(drone_info, @\\
\mbox{}\verb@                 package_trajectories, @\\
\mbox{}\verb@                 used_drones, @\\
\mbox{}\verb@                 animation_file_name_prefix, @\\
\mbox{}\verb@                 algo_name,  @\\
\mbox{}\verb@                 render_trajectory_trails_p = True):@\\
\mbox{}\verb@    import matplotlib.animation as animation@\\
\mbox{}\verb@    from   matplotlib.patches import Circle@\\
\mbox{}\verb@@\\
\mbox{}\verb@    # Set up configurations and parameters for all necessary graphics@\\
\mbox{}\verb@    plt.rc('text', usetex=True)@\\
\mbox{}\verb@    plt.rc('font', family='serif')@\\
\mbox{}\verb@@\\
\mbox{}\verb@    fig, ax = plt.subplots()@\\
\mbox{}\verb@    ax.set_xlim([0,1])@\\
\mbox{}\verb@    ax.set_ylim([0,1])@\\
\mbox{}\verb@    ax.set_aspect('equal')@\\
\mbox{}\verb@@\\
\mbox{}\verb@    ax.set_xticks(np.arange(0, 1, 0.1))@\\
\mbox{}\verb@    ax.set_yticks(np.arange(0, 1, 0.1))@\\
\mbox{}\verb@@\\
\mbox{}\verb@    # Turn on the minor TICKS, which are required for the minor GRID@\\
\mbox{}\verb@    ax.minorticks_on()@\\
\mbox{}\verb@@\\
\mbox{}\verb@    # customize the major grid@\\
\mbox{}\verb@    ax.grid(which='major', linestyle='--', linewidth='0.3', color='red')@\\
\mbox{}\verb@@\\
\mbox{}\verb@    # Customize the minor grid@\\
\mbox{}\verb@    ax.grid(which='minor', linestyle=':', linewidth='0.3', color='black')@\\
\mbox{}\verb@@\\
\mbox{}\verb@    ax.get_xaxis().set_ticklabels([])@\\
\mbox{}\verb@    ax.get_yaxis().set_ticklabels([])@\\
\mbox{}\verb@@\\
\mbox{}\verb@    number_of_drones   = len(used_drones) # A drone trajectory consits of the id of the drone, followed by the actual trajectory trail@\\
\mbox{}\verb@    number_of_packages = len(package_trajectories)@\\
\mbox{}\verb@    colors             = utils_graphics.get_colors(number_of_packages, lightness=0.5)@\\
\mbox{}\verb@    ims                = []@\\
\mbox{}\verb@    @\\
\mbox{}\verb@    # Constant for discretizing each segment inside the trajectories of the packages and drones@\\
\mbox{}\verb@    NUM_SUB_LEGS              = 50 # Number of subsegments within each segment of every trajectory@\\
\mbox{}\verb@    @\\
\mbox{}\verb@    # Arrays keeping track of the states of the packages@\\
\mbox{}\verb@    packages_reached_endpt_p    = [False        for  i    in range(number_of_packages)]@\\
\mbox{}\verb@    packages_traj_num_legs      = [len(traj)-1  for  traj in package_trajectories     ] # the -1 is because the initial position of the package is always included. @\\
\mbox{}\verb@    packages_current_leg_idx    = [0            for  i    in range(number_of_packages)]@\\
\mbox{}\verb@    packages_current_subleg_idx = [0            for  i    in range(number_of_packages)] @\\
\mbox{}\verb@    packages_current_posn       = [traj[0]      for traj in package_trajectories    ]@\\
\mbox{}\verb@@\\
\mbox{}\verb@    # Arrays keeping track of the states of the drones@\\
\mbox{}\verb@    drones_reached_rendz_p    = [False          for  i    in range(number_of_drones)]@\\
\mbox{}\verb@    drones_current_subleg_idx = [0              for i    in range(number_of_drones) ] @\\
\mbox{}\verb@    drones_current_posn       = [drone[0]       for drone in drone_info             ]@\\
\mbox{}\verb@@\\
\mbox{}\verb@    ptraj               = package_trajectories[0]@\\
\mbox{}\verb@    drones_trajectories = zip(drones_current_posn, ptraj)@\\
\mbox{}\verb@@\\
\mbox{}\verb@    # The drone collection process ends, when all packages reach their endpoints@\\
\mbox{}\verb@    image_frame_counter = 0@\\
\mbox{}\verb@    while not(all(packages_reached_endpt_p)): @\\
\mbox{}\verb@        #-----------------------------------------@\\
\mbox{}\verb@        # Update the states of all the packages@\\
\mbox{}\verb@        #-----------------------------------------@\\
\mbox{}\verb@        for pkgidx in range(number_of_packages):@\\
\mbox{}\verb@            #if packages_reached_endpt_p[pkgidx] == False:@\\
\mbox{}\verb@            #    if drones_reached_rendz_p[0] == True:  # any updates to package trajectory happen only if the first drone has reached the package initial position@\\
\mbox{}\verb@                  ptraj = package_trajectories[pkgidx]@\\
\mbox{}\verb@                  if packages_current_subleg_idx[pkgidx] <= NUM_SUB_LEGS-2:@\\
\mbox{}\verb@@\\
\mbox{}\verb@                    packages_current_subleg_idx[pkgidx] += 1     # subleg idx changes@\\
\mbox{}\verb@                    legidx    = packages_current_leg_idx[pkgidx] # the legidx remains the same@\\
\mbox{}\verb@@\\
\mbox{}\verb@                    sublegidx = packages_current_subleg_idx[pkgidx] # shorthand for easier reference in the next two lines@\\
\mbox{}\verb@                    xcurr = np.linspace( ptraj[legidx][0], ptraj[legidx+1][0], NUM_SUB_LEGS+1 )[sublegidx]@\\
\mbox{}\verb@                    ycurr = np.linspace( ptraj[legidx][1], ptraj[legidx+1][1], NUM_SUB_LEGS+1 )[sublegidx]@\\
\mbox{}\verb@                    packages_current_posn[pkgidx]  = [xcurr, ycurr]@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@                  else:@\\
\mbox{}\verb@                    packages_current_subleg_idx[pkgidx] = 0 # reset to 0@\\
\mbox{}\verb@                    packages_current_leg_idx[pkgidx]   += 1 # you have passed onto the next leg@\\
\mbox{}\verb@                    legidx    = packages_current_leg_idx[pkgidx]@\\
\mbox{}\verb@@\\
\mbox{}\verb@                    xcurr, ycurr = ptraj[legidx][0], ptraj[legidx][1] # current position is the zeroth point on the next leg@\\
\mbox{}\verb@                    packages_current_posn[pkgidx]  = [xcurr , ycurr]@\\
\mbox{}\verb@@\\
\mbox{}\verb@                    if packages_current_leg_idx[pkgidx] == packages_traj_num_legs[pkgidx]:@\\
\mbox{}\verb@                        packages_reached_endpt_p[pkgidx] = True@\\
\mbox{}\verb@ @\\
\mbox{}\verb@        #-------------------------------------@\\
\mbox{}\verb@        # Update the states of all the drones@\\
\mbox{}\verb@        #-------------------------------------@\\
\mbox{}\verb@        for dridx in range(number_of_drones):@\\
\mbox{}\verb@                  dtraj = drones_trajectories[dridx]@\\
\mbox{}\verb@                  if drones_current_subleg_idx[dridx] <= NUM_SUB_LEGS-2:@\\
\mbox{}\verb@@\\
\mbox{}\verb@                    drones_current_subleg_idx[dridx] += 1     # subleg idx changes@\\
\mbox{}\verb@@\\
\mbox{}\verb@                    sublegidx = drones_current_subleg_idx[dridx] # shorthand for easier reference in the next two lines@\\
\mbox{}\verb@                    xcurr = np.linspace( dtraj[0][0], dtraj[1][0], NUM_SUB_LEGS+1 )[sublegidx]@\\
\mbox{}\verb@                    ycurr = np.linspace( dtraj[0][1], dtraj[1][1], NUM_SUB_LEGS+1 )[sublegidx]@\\
\mbox{}\verb@                    drones_current_posn[dridx]  = [xcurr, ycurr]@\\
\mbox{}\verb@@\\
\mbox{}\verb@                  else:@\\
\mbox{}\verb@                    drones_current_subleg_idx[dridx] = 0 # reset to 0@\\
\mbox{}\verb@@\\
\mbox{}\verb@                    xcurr, ycurr = dtraj[0][0], dtraj[0][1] # current position is the zeroth point on the next leg@\\
\mbox{}\verb@                    drones_current_posn[dridx]  = [xcurr , ycurr]@\\
\mbox{}\verb@@\\
\mbox{}\verb@                    if drones_current_subleg_idx[dridx] == NUM_SUB_LEGS:@\\
\mbox{}\verb@                        drones_reached_rendz_p[dridx] = True@\\
\mbox{}\verb@           @\\
\mbox{}\verb@         @\\
\mbox{}\verb@        #----------------@\\
\mbox{}\verb@        # Rendering@\\
\mbox{}\verb@        #----------------@\\
\mbox{}\verb@        objs = []@\\
\mbox{}\verb@        # Render all the package trajectories uptil this point in time.  @\\
\mbox{}\verb@        for pkgidx in range(number_of_packages):@\\
\mbox{}\verb@@\\
\mbox{}\verb@          traj                 = package_trajectories[pkgidx]@\\
\mbox{}\verb@          current_package_posn = np.asarray(packages_current_posn[pkgidx])@\\
\mbox{}\verb@          drcurrposn           = np.asarray( drones_current_posn[0]  )@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@          if np.linalg.norm(current_package_posn - drcurrposn) < 1e-1: # advance package only if it has been touhed by drone@\\
\mbox{}\verb@@\\
\mbox{}\verb@            if packages_current_leg_idx[pkgidx] != packages_traj_num_legs[pkgidx]: # the package is still moving@\\
\mbox{}\verb@@\\
\mbox{}\verb@                  xhs = [traj[k][0] for k in range(1+packages_current_leg_idx[pkgidx])] + [current_package_posn[0]]@\\
\mbox{}\verb@                  yhs = [traj[k][1] for k in range(1+packages_current_leg_idx[pkgidx])] + [current_package_posn[1]]@\\
\mbox{}\verb@@\\
\mbox{}\verb@            else: # The package has stopped moving@\\
\mbox{}\verb@                  xhs = [x for (x,y) in traj]@\\
\mbox{}\verb@                  yhs = [y for (x,y) in traj]@\\
\mbox{}\verb@@\\
\mbox{}\verb@            print "-----------------------------------------------------"@\\
\mbox{}\verb@            print Fore.RED, "plotting package line", Style.RESET_ALL@\\
\mbox{}\verb@            print "-----------------------------------------------------"@\\
\mbox{}\verb@            packageline, = ax.plot(np.asarray(xhs),np.asarray(yhs),'o-', @\\
\mbox{}\verb@                                   linewidth=5.0,markersize=10, alpha=0.8, color='#D13131')@\\
\mbox{}\verb@            packageloc   = Circle( np.asarray([current_package_posn[0], current_package_posn[1]]), 0.015, @\\
\mbox{}\verb@                                    facecolor = '#D13131', @\\
\mbox{}\verb@                                    edgecolor='k',  @\\
\mbox{}\verb@                                    alpha=1.00)@\\
\mbox{}\verb@            packagepatch = ax.add_patch(packageloc)@\\
\mbox{}\verb@            objs.append(packageline)@\\
\mbox{}\verb@            objs.append(packagepatch)@\\
\mbox{}\verb@@\\
\mbox{}\verb@        # Render all the drone trajectories   uptil this point in time@\\
\mbox{}\verb@        for dridx in range(number_of_drones):@\\
\mbox{}\verb@            traj                 = drones_trajectories[dridx]@\\
\mbox{}\verb@            current_drone_posn = drones_current_posn[dridx]@\\
\mbox{}\verb@@\\
\mbox{}\verb@            if drones_current_subleg_idx[dridx] != NUM_SUB_LEGS-1 : # the drone is still moving@\\
\mbox{}\verb@@\\
\mbox{}\verb@                  xhs = [ traj[0][0] ] + [current_drone_posn[0]]@\\
\mbox{}\verb@                  yhs = [ traj[0][1] ] + [current_drone_posn[1]]@\\
\mbox{}\verb@@\\
\mbox{}\verb@            else: # The drone has stopped moving@\\
\mbox{}\verb@                  xhs = [x for (x,y) in traj]@\\
\mbox{}\verb@                  yhs = [y for (x,y) in traj]@\\
\mbox{}\verb@@\\
\mbox{}\verb@            print "-----------------------------------------------------"@\\
\mbox{}\verb@            print Fore.RED, "plotting drone line", Style.RESET_ALL@\\
\mbox{}\verb@            print "-----------------------------------------------------"@\\
\mbox{}\verb@            droneline, = ax.plot(np.asarray(xhs),np.asarray(yhs),'o-', @\\
\mbox{}\verb@                                   linewidth=5.0,markersize=10, alpha=0.8, color='g')@\\
\mbox{}\verb@            droneloc   = Circle( np.asarray([current_drone_posn[0], current_drone_posn[1]]), 0.015, @\\
\mbox{}\verb@                                    facecolor = 'g', @\\
\mbox{}\verb@                                    edgecolor='g',  @\\
\mbox{}\verb@                                    alpha=1.00)@\\
\mbox{}\verb@            dronepatch = ax.add_patch(droneloc)@\\
\mbox{}\verb@            objs.append(droneline)@\\
\mbox{}\verb@            objs.append(dronepatch)@\\
\mbox{}\verb@@\\
\mbox{}\verb@        print "........................"@\\
\mbox{}\verb@        print "Appending to ims ", image_frame_counter@\\
\mbox{}\verb@        ims.append(objs) @\\
\mbox{}\verb@        image_frame_counter += 1@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@    debug(Fore.CYAN + "\nStarted constructing ani object"+ Style.RESET_ALL)@\\
\mbox{}\verb@    ani = animation.ArtistAnimation(fig, ims, interval=200, blit=True)@\\
\mbox{}\verb@    debug(Fore.CYAN + "\nFinished constructing ani object"+ Style.RESET_ALL)@\\
\mbox{}\verb@@\\
\mbox{}\verb@    #debug(Fore.MAGENTA + "\nStarted writing animation to disk"+ Style.RESET_ALL)@\\
\mbox{}\verb@    #ani.save(animation_file_name_prefix+'.avi', dpi=100)@\\
\mbox{}\verb@    #debug(Fore.MAGENTA + "\nFinished writing animation to disk"+ Style.RESET_ALL)@\\
\mbox{}\verb@    @\\
\mbox{}\verb@    plt.show()@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@if __name__=="__main__":@\\
\mbox{}\verb@     print "Running Package Handoff"@\\
\mbox{}\verb@     single_pho_run_handler()@\\
\mbox{}\verb@@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtIdentsUsed\nobreak\  \verb@single_pho_run_handler@\nobreak\ \NWlink{nuweb15}{15}.
\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
%{/python-mode}%


\section{Algorithmic Utilities}

%{python-mode}%
\begin{flushleft} \small\label{scrap10}\raggedright\small
\NWtarget{nuweb24}{} \verb@"../src/utils_algo.py"@\nobreak\ {\footnotesize {24}}$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@    @\\
\mbox{}\verb@ @\\
\mbox{}\verb@import numpy as np@\\
\mbox{}\verb@import random@\\
\mbox{}\verb@from colorama import Fore@\\
\mbox{}\verb@from colorama import Style@\\
\mbox{}\verb@@\\
\mbox{}\verb@def vector_chain_from_point_list(pts):@\\
\mbox{}\verb@    vec_chain = []@\\
\mbox{}\verb@    for pair in zip(pts, pts[1:]):@\\
\mbox{}\verb@        tail= np.array (pair[0])@\\
\mbox{}\verb@        head= np.array (pair[1])@\\
\mbox{}\verb@        vec_chain.append(head-tail)@\\
\mbox{}\verb@@\\
\mbox{}\verb@    return vec_chain@\\
\mbox{}\verb@@\\
\mbox{}\verb@def length_polygonal_chain(pts):@\\
\mbox{}\verb@    vec_chain = vector_chain_from_point_list(pts)@\\
\mbox{}\verb@@\\
\mbox{}\verb@    acc = 0@\\
\mbox{}\verb@    for vec in vec_chain:@\\
\mbox{}\verb@        acc = acc + np.linalg.norm(vec)@\\
\mbox{}\verb@    return acc@\\
\mbox{}\verb@def pointify_vector (x):@\\
\mbox{}\verb@    if len(x) % 2 == 0:@\\
\mbox{}\verb@        pts = []@\\
\mbox{}\verb@        for i in range(len(x))[::2]:@\\
\mbox{}\verb@            pts.append( [x[i],x[i+1]] )@\\
\mbox{}\verb@        return pts@\\
\mbox{}\verb@    else :@\\
\mbox{}\verb@        sys.exit('List of items does not have an even length to be able to be pointifyed')@\\
\mbox{}\verb@def flatten_list_of_lists(l):@\\
\mbox{}\verb@       return [item for sublist in l for item in sublist]@\\
\mbox{}\verb@def print_list(xs):@\\
\mbox{}\verb@    for x in xs:@\\
\mbox{}\verb@        print x@\\
\mbox{}\verb@def partial_sums( xs ):@\\
\mbox{}\verb@    psum = 0@\\
\mbox{}\verb@    acc = []@\\
\mbox{}\verb@    for x in xs:@\\
\mbox{}\verb@        psum = psum+x@\\
\mbox{}\verb@        acc.append( psum )@\\
\mbox{}\verb@    return acc@\\
\mbox{}\verb@def are_site_orderings_equal(sites1, sites2):@\\
\mbox{}\verb@@\\
\mbox{}\verb@    for (x1,y1), (x2,y2) in zip(sites1, sites2): @\\
\mbox{}\verb@        if (x1-x2)**2 + (y1-y2)**2 > 1e-8:@\\
\mbox{}\verb@            return False@\\
\mbox{}\verb@    return True@\\
\mbox{}\verb@def bunch_of_non_uniform_random_points(numpts):@\\
\mbox{}\verb@    cluster_size = int(np.sqrt(numpts)) @\\
\mbox{}\verb@    numcenters   = cluster_size@\\
\mbox{}\verb@    @\\
\mbox{}\verb@    import scipy@\\
\mbox{}\verb@    import random@\\
\mbox{}\verb@    centers = scipy.rand(numcenters,2).tolist()@\\
\mbox{}\verb@@\\
\mbox{}\verb@    scale, points = 4.0, []@\\
\mbox{}\verb@    for c in centers:@\\
\mbox{}\verb@        cx, cy = c[0], c[1]@\\
\mbox{}\verb@        # For current center $c$ of this loop, generate \verb|cluster_size| points uniformly in a square centered at it@\\
\mbox{}\verb@           @\\
\mbox{}\verb@        sq_size      = min(cx,1-cx,cy, 1-cy)@\\
\mbox{}\verb@        loc_pts_x    = np.random.uniform(low=cx-sq_size/scale, high=cx+sq_size/scale, size=(cluster_size,))@\\
\mbox{}\verb@        loc_pts_y    = np.random.uniform(low=cy-sq_size/scale, high=cy+sq_size/scale, size=(cluster_size,))@\\
\mbox{}\verb@        points.extend(zip(loc_pts_x, loc_pts_y))@\\
\mbox{}\verb@        @\\
\mbox{}\verb@@\\
\mbox{}\verb@    # Whatever number of points are left to be generated, generate them uniformly inside the unit-square@\\
\mbox{}\verb@       @\\
\mbox{}\verb@    num_remaining_pts = numpts - cluster_size * numcenters@\\
\mbox{}\verb@    remaining_pts = scipy.rand(num_remaining_pts, 2).tolist()@\\
\mbox{}\verb@    points.extend(remaining_pts)@\\
\mbox{}\verb@    @\\
\mbox{}\verb@@\\
\mbox{}\verb@    return points@\\
\mbox{}\verb@    @\\
\mbox{}\verb@def write_to_yaml_file(data, dir_name, file_name):@\\
\mbox{}\verb@   import yaml@\\
\mbox{}\verb@   with open(dir_name + '/' + file_name, 'w') as outfile:@\\
\mbox{}\verb@     yaml.dump( data, outfile, default_flow_style = False)@\\
\mbox{}\verb@ @\\
\mbox{}\verb@@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}

\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
%{/python-mode}%



\section{Graphical Utilities}


%{python-mode}%
\begin{flushleft} \small\label{scrap11}\raggedright\small
\NWtarget{nuweb26}{} \verb@"../src/utils_graphics.py"@\nobreak\ {\footnotesize {26}}$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@    @\\
\mbox{}\verb@@\\
\mbox{}\verb@from matplotlib import rc@\\
\mbox{}\verb@from colorama import Fore@\\
\mbox{}\verb@from colorama import Style@\\
\mbox{}\verb@from scipy.optimize import minimize@\\
\mbox{}\verb@from sklearn.cluster import KMeans@\\
\mbox{}\verb@import argparse@\\
\mbox{}\verb@import itertools@\\
\mbox{}\verb@import math@\\
\mbox{}\verb@import matplotlib as mpl@\\
\mbox{}\verb@import matplotlib.pyplot as plt@\\
\mbox{}\verb@import numpy as np@\\
\mbox{}\verb@import os@\\
\mbox{}\verb@import pprint as pp@\\
\mbox{}\verb@import randomcolor @\\
\mbox{}\verb@import sys@\\
\mbox{}\verb@import time@\\
\mbox{}\verb@@\\
\mbox{}\verb@xlim, ylim = [0,1], [0,1]@\\
\mbox{}\verb@@\\
\mbox{}\verb@# Borrowed from https://stackoverflow.com/a/9701141@\\
\mbox{}\verb@import numpy as np@\\
\mbox{}\verb@import colorsys@\\
\mbox{}\verb@@\\
\mbox{}\verb@def get_colors(num_colors, lightness=0.2):@\\
\mbox{}\verb@    colors=[]@\\
\mbox{}\verb@    for i in np.arange(60., 360., 300. / num_colors):@\\
\mbox{}\verb@        hue        = i/360.0@\\
\mbox{}\verb@        saturation = 0.95@\\
\mbox{}\verb@        colors.append(colorsys.hls_to_rgb(hue, lightness, saturation))@\\
\mbox{}\verb@    return colors@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}

\item{}
\end{list}
\vspace{4ex}
\end{flushleft}
%{/python-mode}%
\end{appendices}

\end{document}
