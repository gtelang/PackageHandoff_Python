\documentclass[10pt, english, oneside]{report}
\input{settings.tex}

\newcommand{\tss}{\textsuperscript}

\title{\huge{\bfseries{Coordinating Heterogenous Agents for Fast Package Delivery --- The Package Handoff Problem}}}
\author{Jie Gao $^1$, 
       Kien Huynh $^1$, 
       Joseph S. B. Mitchell $^2$, 
       Gaurish Telang$^2$}
\date{
\small{$^1$ Department of Computer Science, Stony Brook University \\%
$^2$ Department of Applied Mathematics and Statistics, Stony Brook University} \\[2ex]% 
}

\begin{document}
\maketitle

\begin{abstract}
How do you get a package from an initial location $S$ to a destination point $T$ using a 
fleet of ``heterogenous'' carrier agents (e.g. drones, taxis). By ``heterogenous'' we mean 
the two agents can have different capabilities like different maximum speed
or different fuel capacity. 

\vspace{2mm}

In the simplest version of the category of problems, 
we are given as input the initial locations of $n$  agents in $\mathbb{R}^2$ 
each capable of a maximum speed $u_i >0$ (where $u_i$ need \textsl{not} be equal to $v_j$ for $i \neq j$). 
Each agent can pick up the package and move to another point to \textit{rendezvous with} \underline{and} 
\textit{hand off} the 
package to another agent. This other agent then either proceeds to $T$ or decides to meet with 
and hand off the package to another agent, until the last agent decides to head directly to $T$. 

\vspace{2mm}

The objective is to get the agents to cooperate to send the package from $S$ to $T$ in the 
least possible time. We call this the \textit{Package Handoff Problem}. 

\vspace{2mm}

To solve this problem and its various avatars we need to 

\vspace{2mm}

\begin{enumerate}
\item Figure out which subset $S = \{i_1, i_2, \ldots i_k\}$ of the drones are used in the optimal schedule. 
\item Find the order in which the handoffs happend between the drones used in a schedule. 
\item Calculate the ``handoff'' points where drone $i_m$ hands over the package to drone 
      $i_{m+1}$, for $1 \leq m \leq k-1$
\end{enumerate}

\vspace{2mm}

This report is an algorithmic study of various heuristics developed to solve different variants of Package Handoff.

\end{abstract}


\newpage
\setcounter{tocdepth}{2}
\tableofcontents

%--------------------------
\chapter{Single Package Handoff}

\section{Introduction}
\begin{wrapfigure}{R}{0.5\textwidth}
  \begin{center}
    \includegraphics[width=6cm]{docs/introex.eps}
    \caption{An instance of the Package Handoff problem for a single package being transported from $S$ to $T$. 
     Agents are located at the dots marked in black. The package travels along the red path. The agents all have 
     different velocities, and in this example, assumed to have infinite battery capacity.}%
    \label{fig:introex}%
  \end{center}
\end{wrapfigure}

How do you get a package from an initial location $S$ to a destination point $T$ using a fleet of ``heterogenous'' carrier agents 
(e.g. drones, taxis). By ``heterogenous'' we mean the two agents can have different capabilities like 
different maximum speed or different fuel capacity. 


In the simplest version of the category of problems, 
we are given as input the initial locations of $n$  agents in $\mathbb{R}^2$ 
each capable of a maximum speed $u_i >0$ (where $u_i$ need not be equal to $v_j$ for $i \neq j$).
Each agent can pick up the package and move to another point to \textit{rendezvous with} and 
\textit{hand off} the 
package to another agent. This other agent then either proceeds to $T$ or decides to meet with 
and hand off the package to another agent \footnote{If it makes the package get to $T$ faster} 
and so on and so forth. 

The objective is to get the agents to cooperate to send the package from $S$ to $T$ in the 
least possible time. We call this the \textit{Package Handoff Problem}. 

To solve this problem and its various avatars 
\footnote{Say when there are multiple packages to be delivered or a bound on fuel} 
we need to 


\begin{enumerate}
\item Figure out which subset $S = \{i_1, i_2, \ldots i_k\}$ of the drones are used in the optimal schedule. 
\item Find the order in which the handoffs happend between the drones used in a schedule. 
\item Calculate the ``handoff'' points where drone $i_m$ hands over the package to drone $i_{m+1}$ 
\footnote{The last drone in the computed schedule, of course, flies directly to $T$}
\end{enumerate}

A real world instance of the basic Package Handoff problem, as described in the abstract, is when a 
ride hailing service  must co-ordinate its fleet of taxis to transport a passenger from a given location 
in the quickest possible time to the target destination on the map. In this model, 
a passenger ``hops rides'' when two taxis meet: a taxi first gets to the passenger and takes him/her to 
a point where it rendezvous with another taxi, at which point the passenger swaps taxis. This process continues 
until the passenger hops onto a taxi that goes straight to the target.  

This package handoff process is depicted in \autoref{fig:introex}. 


\section{A note on source code}
Many of the heuristics algorithms described here are implemented as literate programs \cite{Knuth:1984:LP:473.479} 
in Python 2.7.12 using the NuWeb tool \cite{briggs1992nuweb} available from \url{http://nuweb.sourceforge.net/}
alongside associated theoretical and empirical analysis. All the algorithmic code goes into the 
file \verb|pholib.py|, and any associated helper codes go into the files which are named as \verb|utils_*.py|. 
The code for these utility files has been given in the appendices. 

The \verb|pholib.py| file looks like 

%{python-mode}%
@O src/pholib.py -cp @{
from colorama import Fore, Style
from matplotlib import rc
import matplotlib as mpl
import matplotlib.pyplot as plt
from scipy.optimize import minimize
from sklearn.cluster import KMeans
import numpy as np
import argparse, inspect, itertools, logging
import os, time, sys
import pprint as pp, randomcolor 
import utils_algo, utils_graphics

@< Algorithms @>
@< Run Handlers @>
@< Plotting @>
@|  @}
%{/python-mode}%

The chapters are devoted to fleshing out the chunks \textlangle \verb|Algorithms|\textrangle and 
\textlangle\verb|Experiments|\textrangle.  The \newline \textlangle \verb|Run Handlers|\textrangle and 
\textlangle \verb|Plotting|\textrangle \; chunks is mainly to deal with interactive matplotlib input, 
and as such are boring and banished to the Appendix \Winkey . 

All source code files are tangled to the \verb|src| directory. The point of entry for the code are 
\verb|main*.py| which are implemented separately in the \verb|src| directory, since their contents 
can change based on what library code is being called 
for during development and testing. Since these files are very short and the mechanics clear, 
they are implemented as standalone files (i.e. not inside this document) but directly in the \verb|src| folder 
itself. To run the code in interactive mode run the code as \verb|python src/main_interactive.py| on a 
Unix / Windows terminal in the root folder of the project \footnote{This code has been tested on an 64 bit 
machine running Linux Mint 18.3 (Sylvia) running the Linux Kernel version 4.10.0-38-generic with an 
Intel(R) Core(TM) i7 CPU 960 @@ 3.20GHz CPU}. 

For a short overview of previous work on this problem see Appendix. 

The \verb|README| file containing instructions for running the source code and experiments is listed in the 
appendix (also available on the Github repository)

Each of the following sections correspond to a fixed variant of the package handoff problem and describe
algorithms for that specific variant. Enough talk! Onto algorithms! 

\section{Problem: Unlimited Fuel, Different Drone Speeds}

Much of the machinery developed in solving this basic basic basic question will be generalized and extended to 
other variants of the package handoff problem. 

We repeat the problem definition and fix some notation that will be used for the remainder 
of the section 

\begin{displayquote}
  We are given as input the initial locations $P_i$ of $n$  agents in $\mathbb{R}^2$ 
each capable of a maximum speed $u_i >0$ (where $u_i$ need not be equal to $u_j$ for $i \neq j$).
Each agent can pick up the package and move to another point to \textit{rendezvous with} and 
\textit{hand off} the 
package to another agent. This other agent then either proceeds to $T$ or decides to meet with 
and hand off the package to another agent and so on. 
The objective is to get the agents to cooperate to send the package from $S$ to $T$ in the 
least possible time. 
\end{displayquote}

We represent the handoff points as follows $H_{i_1} \ldots H_{i_k}$ for $0 \leq i_0, \ldots i_k \leq n$ stand 
for points where the drones with labels $i_0, \ldots i_k$ hand the package off in that order. More precisely 
$H_{i_j}$ is the point where drone $i_{j-1}$ hands off the package to drone $i_j$ for $1 \leq j \leq k$.  

A solution to the package handoff problem is completely specified by computing the handoff points \textit{and} the 
drone ids involved in the exchange at each handoff point. 

The optimal schedule is denoted $OPT$. It is easy to see the statements of the following structural lemma always 
hold for $OPT$. 

\begin{flem}

In $OPT$
\begin{alphalist}
\item A package is always transferred to a faster drone at a handoff point. 
\item A drone handles a package at most once i.e. if a drone hands off the package, 
      it will never be involved in a handling that package again. 
\item All drones involved in the handoff start moving simultaneously at time $t=0$ 
\item No two drones wait at a rendezvous point before rendezvous happens. 
     \footnote{waiting can happen in other problem variants 
     say when there is limited fuel or only a finite set of 
     allowed rendezvous points}
\item The path of the package is a radially monotone piecewise straight polygonal curve with respect to the 
    direction ST no matter what the initial positions $P_i$ or speeds $u_i$ of the drones. 
\item $\frac{|ST|}{v_{max}}$ is a (trivial) lower bound for $OPT$, where $v_{max}$ denotes the speed of the fastest drone. 
\end{alphalist}
\end{flem}

\begin{proof}
\todo[inline]{TODO!}
\end{proof}

\newpage
\subsection{Handoff in a fixed order}
\label{ssec:fixorder}
If we know the drones involved in the handoff \textit{along with} the order of handoff 
then we can compute the handoff points --- and hence the path of the package --- exactly via 
convex optimization as outlined in Lemma \autoref{lem:fixorder}. This fact will be exploited in many 
heuristics: such methods will compute a subset of drones involved in the handoff (alongwith 
the handoff order) followed by a call to the convex program. 


\begin{figure}[H]
\centering
\includegraphics[width=8cm]{docs/pho-cvx.pdf}
\caption{The path of the package is shown in red. The drones invovled in the handoff are 
labelled $P_i$ in the prespecified handoff order.}
\end{figure}
\label{fig:fixorder}

\begin{flem} \label{lem:fixorder}
Given as input are drones with initial positions $P_i \in \RR^2$, with speeds $u_i>0$ 
for  $1 \leq i \leq r-1$, the intial position $S$ and final destination $T$ 
for the package. \footnote{See \autoref{fig:fixorder} for an illustration of the notation used in this lemma} 
The drones are expected to transport the package by handing of the package in the order $1,2,\ldots, r$.
Let $t_i$ denote the departure time on a global clock from the $i$'th handoff point $X_i$. 

Then the minimum time and handoff points for transporting the package and the handoff points 
can be calculated by the following convex program

\begin{equation*}
\min_{t_i, X_i} \; \; \; t_{r-1} + \frac{||T-X_{r-1}||}{u_{r-1}}
\end{equation*}

subject to the constraints

\begin{align*}
X_0 &= S\\  
t_i &\geq \frac{||P_i-X_i||}{u_i} \qquad \qquad 0 \leq i \leq r-1\\
t_i + \frac{||X_{i+1}-X_i||}{u_i} &\leq t_{i+1} \qquad \qquad \qquad \;\;\;\; 0 \leq i \leq r-2
\end{align*}

\end{flem}


The following function is just an implentation of the convex program just described. 
Here \verb|drone_info| is a list 
of tuples, where each tuple consits of the initial position and speed of the drone. The order of the 
drones is assumed to be that in which the list of drones is provided. \verb|source| and \verb|target|
are just coordinate locations of $S$ and $T$ respectively. We use the CVXPY \cite{cvxpy} library 
as a black-box convex optimization solver. 

%{python-mode}%
@d Algorithms 
@{def algo_pho_exact_given_order_of_drones ( drone_info, source, target ):
    import cvxpy as cp

    source = np.asarray(source)
    target = np.asarray(target)

    r = len(drone_info) 
    source = np.asarray(source)
    target = np.asarray(target)
    
    # Variables for rendezvous points of drone with package
    X, t = [], []
    for i in range(r):
       X.append(cp.Variable(2)) # vector variable
       t.append(cp.Variable( )) # scalar variable

    # Constraints 
    constraints_S = [  X[0] == source ]

    constraints_I = [] 
    for i in range(r):
      constraints_I.append(0.0 <= t[i])
      constraints_I.append(t[i] >= cp.norm(np.asarray(drone_info[i][0])-X[i])/drone_info[i][1])

    constraints_L = []
    for i in range(r-1):
      constraints_L.append(t[i] + cp.norm(X[i+1] - X[i])/drone_info[i][1] <= t[i+1])

    objective = cp.Minimize(t[r-1]+cp.norm(target-X[r-1])/drone_info[r-1][1])

    prob = cp.Problem(objective, constraints_S + constraints_I + constraints_L)
    print Fore.CYAN
    prob.solve(solver=cp.SCS,verbose=True)
    print Style.RESET_ALL
    
    package_trail = [ np.asarray(X[i].value) for i in range(r) ] + [ target ]
    return package_trail
@| @}
%{/python-mode}%


We next describe a heuristic that use Continuous Dijkstra \cite{mitchell2000geometric} 
type approach in computing approximate solutions to $OPT$.

\subsection{Algorithm: One Dimensional Greedy Wavefront}
\label{ssec:odw}

In this heuristic we first constrain the package to travel along the line $\vec{ST}$, then compute the 
subset of the drones involved in the schedule, and finally pass of the list of drones involved to the convex
program given in Lemma \autoref{lem:fixorder} to calculate the rendezvous points. 


% \begin{algorithm}[H]
% \DontPrintSemicolon % Some LaTeX compilers require you to use \dontprintsemicolon instead 
% \KwIn{
% \begin{enumerate}
% \item Coordinates of initial position of source $S$ and target $T$ of the package.
% \item Coordinates of the onitial positions $P_i$ of each drone $1 \leq i \leq n$.
% \item Maximum possible speed $u_i$ of each drone $1 \leq i \leq n$. 
% \end{enumerate}

% }
% \KwOut{

% \begin{enumerate}
%  \item  \myblue{$t^*$}: The time required for the package to get from $S$ to $T$.
%  \item  \myblue{$L = (i_1, i_2, \ldots, i_k)$} : An ordered list of indices of the drones involved in the handoff. 
%  \item \myblue{$\mathcal{H} =  \{ \, S \, \} \cup \{ \, H_{i_j} \mid j\geq 2  \, \}$}:  An ordered list of handoff points.
% $H_{i_j} \in \RR^2$ is where the drone with index $i_j$ picks up the package 
%        \textit{from} drone $i_{j-1}$. 
% \end{enumerate}
% }

% \vspace{4mm}

% $t \gets 0$ \tcp*[h]{Time on the global clock} \;
% $wavelets \gets [ (i, 0) \mid 0 \leq i \leq n ]$ \tcp*[h]{Active Wavelets: indices and current radius}\;

% \vspace{2mm}
% \tcc*[h]{Find first wavelet to reach $S$ and update $wavelets$} \;

% \tcc*[h]{Start wavelet expansion from $S$} \;
% \For{$i \gets 1$ \textbf{to} $r$}{
%   \While{$n \geq c_i$} {
%     $C \gets C \cup \{c_i\}$   \;
%     $n \gets n - c_i$ 
%   }
% }
% \Return{$t^*, L, \mathcal{H}$}\;
% \caption{{\sc One dimensional greedy wavefront}}
% \label{algo:odgw}
% \end{algorithm}

\begin{figure}
    \centering
    \begin{minipage}{0.45\textwidth}
        \centering
        \includegraphics[width=8cm]{docs/straight-line-pho-ex.pdf}
        \caption{first figure}
     \caption{The package travels along the straight line $\vec{ST}$. The point where drone $A$ hands off the 
              package to drone $B$ depicted as $H_B$, and similarly for other drones. Drones involved in the handoff 
              are marked in pink. Those not involved are marked in gray. Two drones may have different speed.}

    \end{minipage}\hfill
    \begin{minipage}{0.45\textwidth}
        \centering
        \includegraphics[width=8cm]{docs/circular_wavelets_intersect_along_st.pdf}
        \caption{second figure}
     \caption{Intersection of two expanding wavelets along $\vec{H_iT}$. The figure shows an overlay of  
              snapshots of two times; one at time $t$ (when the package has just been handed off to drone 
              $i$ at $H_i$) and another at time $t + \delta t$ (when a wavelet corresponding a drone faster 
              than drone $i$ meets it at at $M$)}
    \end{minipage}
\end{figure}
\label{fig:refalgoodw}

Here is a sketch of the implementation of \verb|algo_odw|. Use \autoref{fig:refalgoodw} as a reference while reading the
description below. 

%{python-mode}%
@d Algorithms @{
def algo_odw(drone_info, source, target, plot_tour_p = False):

    from scipy.optimize import minimize
    source     = np.asarray(source)
    target     = np.asarray(target)
    sthat      = (target-source)/np.linalg.norm(target-source)
    numdrones  = len(drone_info)
    clock_time = 0.0  # time on the global clock

    @< Find the drone which can get to the source the quickest @>
    package_reached_p      = False

    while not(package_reached_p):
         @< Find a faster wavelet that meets up with the package wavelet along line $\vec{ST}$ at the earliest @>        
         @< Check if package wavelet reaches target before meeting wavelet computed above. Update states accordingly@>

    @<Run the convex optimization solver to retrieve the exact tour \verb|package_trail_cvx| for given drone order@>      
    @<Plot tour if \verb|plot_tour_p == True|@>

    return used_drones, package_trail_straight, mspan_straight, package_trail_cvx, mspan_cvx
@| algo_odw @}
%{/python-mode}%
 
At the start of the algorithm, the package is stationary. We find the drone which can reach it at the earliest, 
and update the time on the global clock. It is easy to see that this drone must be involved in the optimal handoff 
schedule. 

%{python-mode}%
@d   Find the drone which can get to the source the quickest @{
tmin = np.inf
imin = None
for idx in range(numdrones):
         initdroneposn = drone_info[idx][0]
         dronespeed    = drone_info[idx][1]
         tmin_idx = time_of_travel(initdroneposn, source, dronespeed)

         if tmin_idx < tmin:
             tmin = tmin_idx
             imin = idx 

clock_time = tmin

current_package_handler_idx = imin
current_package_position    = source

drone_pool = range(numdrones)
drone_pool.remove(imin) 
used_drones = [imin]
package_trail_straight = [current_package_position]
@| @}
%{/python-mode}%

In the optimal handoff order, as we have already noted, the handoff happens from a slower to a faster robot. 
In the next chunk, we calculate the wavelet that meets the package wavelet at the earliest, subject to the 
constraint that the wavelet should be faster than the package wavelet. 


%{python-mode}%
@d Find a faster wavelet that meets up with the package wavelet along line $\vec{ST}$  at the earliest @{   
tI_min     = np.inf
idx_tI_min = None
for idx in drone_pool:

      us = drone_info[current_package_handler_idx][1]
      up = drone_info[idx][1]

      if up <= us: # slower drones are useless, so skip rest of the iteration
          continue 
      else: 
        s = current_package_position 
        p = np.asarray(drone_info[idx][0]) 

        tI, x = get_interception_time_and_x(s, us, p, up, target, clock_time)

        if tI < tI_min:
           tI_min     = tI
           idx_tI_min = idx
@| @}
%{/python-mode}%



We now implement \verb|get_interception_time_and_x|, the time on the global clock when two wavelets meet
and position along the line $\vec{ST}$. More precisely, 
the function computes the time on the global clock at which a wavelet that started expanding from 
$P=(\alpha,\beta)$ at time 0, meets a wavelet that started expanding from $S$ at time $t_0$ along 
the half-line $\vec{ST}$. We make a change of coordinages such that $\vec{ST}$ is horizontal and 
pointing to the right, and $S=(0,0)$ as in \autoref{fig:getinterceptiontimeandx}.


\begin{figure}[H]
\centering
   \includegraphics[width=8cm]{docs/get_interception_time_and_x.pdf}
\caption{Reference figure for the function \texttt{get\_interception\_time\_and\_x}.  
         Without loss of generality (by changing the coordinate system) we can assume 
         the line $\vec{ST}$ to be horizontal.}
\end{figure}
\label{fig:getinterceptiontimeandx}



\begin{IEEEeqnarray}{rCl}
\frac{x-0}{u_S}   &=& \frac{\sqrt{(x-\alpha)^2 + \beta^2}}{u_P} - t_0  \nonumber \\
\left(\frac{x}{u_S} + t_0 \right)^2 & = & \frac{(x-\alpha)^2 + \beta^2}{u_P^2}   \nonumber 
\end{IEEEeqnarray}


Rearranging the terms, we get a quadratic equation in $x$ that we can solve solve using standard 
non-linear solvers \footnote{Using the exact formula for solving the quadratic equation is unstable
in computer arithmetic as is well known from numerical analysis. To avoid such tricky issues, it is best
to use the standard \texttt{roots} solver for polynomials available from numpy \url{https://docs.scipy.org/doc/numpy/reference/generated/numpy.roots.html}}. 

\begin{IEEEeqnarray}{rCl}
x^2 \left( \frac{1}{u_S^2} - \frac{1}{u_P^2}\right)   + x\left( \frac{2t_0}{u_S} + \frac{2\alpha}{u_P^2}\right)
+ \left(   t_0^2 - \frac{\alpha^2}{u_P^2} - \frac{\beta^2}{u_P^2} \right)    &=& 0 
\end{IEEEeqnarray}

Once we obtain $x$ getting the interception time $t_I$ (i.e. the time on the global clock 
when the two wavelets meet) as $t_I = \frac{x}{u_S} + t_0$.

%{python-mode}%
@d Algorithms @{ 
def get_interception_time_and_x(s, us, p, up, t, t0) :
    
    @<Change coordinates to make $s=(0,0)$ and $t$ to lie along X-axis as in \autoref{fig:getinterceptiontime} @>

    # Solve quadratic equation as documented in main text
    qroots = np.roots([ (1.0/us**2 - 1.0/up**2), 
                        2*t0/us + 2*alpha/up**2 , 
                        t0**2 - alpha**2/up**2 - beta**2/up**2])

    # The quadratic should always have a root. 
    qroots = np.real(qroots) # in case the imaginary parts
    qroots.sort()            # of the roots are really small

    x = None
    for root in qroots:
        if root > 0.0:
           x = root
           break
    assert abs(x/us+t0 - np.sqrt((x-alpha)**2 + beta**2)/up) <= 1e-6 , \
           "Quadratic not solved perfectly"

    tI = x/us + t0
    return tI, x
@| get_interception_time_and_x @}
%{/python-mode}%

Massage the input into such that $\vec{ST}$ lies along the positive X-axis as in \autoref{fig:getinterceptiontime}. 

%{python-mode}%
@d Change coordinates to make $s=(0,0)$ and $t$ to lie along X-axis as in \autoref{fig:getinterceptiontime}  @{   
t_m = t - s # the _m subscript stands for modify
t_m = t_m / np.linalg.norm(t_m) # normalize to unit

# For rotating a vector clockwise by theta, 
# to get the vector t_m into alignment with (1,0)
costh = t_m[0]/np.sqrt(t_m[0]**2 + t_m[1]**2)
sinth = t_m[1]/np.sqrt(t_m[0]**2 + t_m[1]**2)

rotmat = np.asarray([[costh, sinth],
                     [-sinth, costh]])

assert np.linalg.norm((rotmat.dot(t_m) - np.asarray([1,0]))) <= 1e-6,\
       "Rotation matrix did not work properly. t_m should get rotated\
        onto [1,0] after this transformation"

p_shift  = p - s
p_rot    = rotmat.dot(p_shift)
[alpha, beta] = p_rot
@| @}
%{/python-mode}%




If the package reaches the target before it meets any other wavelet along the line $\vec{ST}$, then there is no point in 
handing off the package to some other drone. Just terminate the handoff! Otherwise handoff the package and update
variables accordingly.  


%{python-mode}%
@d Check if package wavelet reaches target before meeting wavelet computed above. Update states accordingly @{   
time_to_target_without_handoff = np.linalg.norm((target-current_package_position))/ \
                                 drone_info[current_package_handler_idx][1]

if time_to_target_without_handoff < tI_min : 
     package_reached_p = True
     package_trail_straight.append(target)

else:
     @< Update package information (current speed, position etc.) and drone information (available and used drones)  @>
@| @}
%{/python-mode}%




%{python-mode}%
@d Update package information (current speed, position etc.) and drone information (available and used drones) @{   
package_handler_speed    = drone_info[current_package_handler_idx][1] 
current_package_position = current_package_position + \
                            package_handler_speed * (tI_min - clock_time) *  sthat
package_trail_straight.append(current_package_position)

clock_time                  = tI_min 
current_package_handler_idx = idx_tI_min

drone_pool.remove(idx_tI_min)
used_drones.append(idx_tI_min)  
@| @}
%{/python-mode}%


Now that we have a list of drones involved in the handoff, (along with an approximate trail for the package) 
we use the convex optimization solver to extract the exact tour for the given set of drones. We plot both tours
for a visual comparison, if \verb|plot_tour_p| is set to \verb|True|.

%{python-mode}%
@d Run the convex optimization solver to retrieve the exact tour \verb|package_trail_cvx|  for given drone order @{   
package_trail_cvx =  algo_pho_exact_given_order_of_drones(\
                             [drone_info[idx] for idx in used_drones],source,target)

mspan_straight    = makespan(drone_info, used_drones, package_trail_straight)
mspan_cvx         = makespan(drone_info, used_drones, package_trail_cvx)
@| @}
%{/python-mode}%



The next chunk implements a function that computes the makespan of the delivery process, i.e. the time it takes
for the package to get from the source to the destination, given the points on the trajectory of the package
and the drones involved alongwith the handoff order. The variable \verb|drone_info| is list of 
tuples, where the \verb|i|\tss{th} tuple  gives the initial position and speed of the drone 
in the zeroth and first position respectively. The function \verb|time_of_travel| is simply a function
used to compute the time it takes for an agent with uniform speed to travel between a given \verb|source|
and \verb|target|. Both \verb|source| and \verb|target| are numpy arrays of size two (if not, they are converted into 
numpy arrays at the start of the function). 

%{python-mode}%
@d Algorithms @{
def time_of_travel(start, stop, speed):
     start = np.asarray(start)
     stop  = np.asarray(stop)
     return np.linalg.norm(stop-start)/speed

def extract_coordinates(points):

    xs, ys = [], []
    for pt in points:
        xs.append(pt[0])
        ys.append(pt[1])
    return np.asarray(xs), np.asarray(ys)

def makespan(drone_info, used_drones, package_trail):

    assert len(package_trail) == len(used_drones)+1, ""
    makespan = 0.0   
    counter  = 0    
    for idx in used_drones:
         dronespeed    = drone_info[idx][1]          

         makespan += time_of_travel(package_trail[counter],\
                                    package_trail[counter+1],
                                    dronespeed) 
         counter += 1
    
    return makespan
  
@| makespan, extract_coordinates time_of_travel @}
%{/python-mode}%




%{python-mode}%
@d Plot tour if \verb|plot_tour_p == True| @{   
if plot_tour_p:
     fig0, ax0 = plt.subplots()
     plot_tour(fig0, ax0, "ODW: Straight Line", source, target, \
               drone_info, used_drones, package_trail_straight)

     fig1, ax1 = plt.subplots()
     plot_tour(fig1, ax1, "ODW: Straight Line, Post Convex Optimization", source, target, \
               drone_info, used_drones, package_trail_cvx)
     plt.show()
@| @}
%{/python-mode}%










\chapter{Multiple Package Handoff}

% \begin{figure}[H]
% \centering
% \includegraphics[width=10cm]{asy2d/example.eps}
% \end{figure}



What's more fun than delivering a single package? Delivering multiple packages! The moment, we generalize 
from a single to multiple packages the problem becomes enormously more interesting along with several 
possible generlizations to the statement of the problem. Each section is dedicated to one such generalization
along with a description of algorithms and heuristics to solve them. 


\begin{figure}[H]
\centering
\includegraphics[width=6cm]{example-grid-100x100pt}
\end{figure}
\label{fig:multiplepho-assignment}


\section{Problem: Drone Assignment To Packages}
We are given as input the initial locations $P_i$ of $n$  agents in $\mathbb{R}^2$ 
each capable of a maximum speed $u_i >0$.
Also given are $k \leq n$ source target pairs $S_j, T_j$ where $S_j$ for $j \leq k$ 
denotes the beginning position of a package that has to get to target point $T_j$.  
Each agent is allowed to be involved in the transport of at most one package. More 
than one agent is allowed to be assigned to a package. Agents  assigned to a package 
can coordinate to rendezvous and relay the package from its source to its destination 
(exactly as in the single package handoff case)

The objective is to perform an assignment of agents to the packages so that the time 
taken to deliver the last package to its target is minimized, i.e. the makespan of 
the deliveries of the packages from sources to their destinations is minimized.  
See \label{fig:multiplepho-assignment} for an example instance (alongside tours computed
for the packages and drones by the ``match and move'' algorithm to be described next.)

\subsection{Algorithm: Match-and-Move}
\label{ssec:matchmove}

The approach taken here is again based on Continuous Dijkstra. 
At the start of the algorithm, we assume each of the packages 
are constrained to travel along the the straight line segment joining 
its source and target.  We then imagine wavelets expanding at speed $u_i$ 
from each of the drone positions and perform an incremental assignment of the 
drones to the packages as the wavelet expansion proceeds. 
The assignment is done via bottleneck matching in an appropriately 
constructed bipartite graph. The matching algorithm is run everytime 
a certain ``event'' is detected. 

Once the final assignment of drones to packages has been performed, 
we run the convex optimization solver desribed in \autoref{ssec:fixorder}
to get the exact trajectory for each of the packages for the given assignment.

The rest of this section is devoted to making the above description 
more precise. First we give an outline of  \verb|algo_matchmove| that will be 
fleshed out in subsequent subsections. 

%{python-mode}%
@d Algorithms 
@{import networkx as nx 

def algo_matchmove(drone_info, sources, targets, plot_tour_p = False):

     @<Sanity checks on input for \verb|algo_matchmove| @>
     @<Basic setup@>
    
     while not all(package_delivered_p):
          @< Construct bipartite graph $G$ on drone wavelets and package wavelets @>
          @< Get a bottleneck matching on $G$ @>
          @< Expand drone wavelets till an event of either Type \rnum{1} or Type \rnum{2} is detected @>
          @< Update drone pool and package states@>

     @< Run convex optimization solver to get improved tours for drones and packages @>
     @< Plot movement of packages and drones if \verb|plot_tour_p == True | @> 
     #return pass pass pass pass pass 
@| algo_matchmove @}
%{/python-mode}%

\subsubsection{Sanity Checks, and Basic Setup}
\label{ssec:sancheck}
To start things off, we enforce the constraint that the number of drones 
should be greater than the number of packages. Also the number of 
packages is equal to the number of sources which in turn is equal to the 
number of targets. These conditions are encoded as sanity checks 
in the code chunk below that is incorporated at the beginning of the 
function 

%{python-mode}%
@d Sanity checks on input for \verb|algo_matchmove| @{   
assert len(drone_info) >= len(sources),\
   "Num drones should be >= the num source-target pairs"

assert len(sources) == len(targets),\
   "Num sources should be == Num targets"
@| @}
%{/python-mode}%


The lists \verb|sources|, \verb|targets|, \verb|drone_initposns| and \verb|drone_speeds| 
are all \textit{constant} throughout the execution of the algorithm. They denote the list of sources, 
targets, initial position and speeds of the drones respectively. For package \verb|i|, its source and 
destination are respectively \verb|source[i]| and \verb|target[i]|. 


Then, we create some lists that keep track of various states in the 
main \texttt{while} loop of the algorithm. 

\begin{description}
\item[A. \texttt{package\_delivered\_p}] is a Boolean list
       where the \verb|i|\textsuperscript{th} element keeps track whether 
       the package with id \verb|i| has been delivered to its destination. 
       The main \verb|while| loop stops when all flags are set to \verb|True|. 
     
\item[B. \texttt{drone\_pool}] is a list of ids of drones that can be 
     considered for the bottleneck matching process for the next iteration of 
     the \verb|while| loop.  

\item[C. \texttt{drone\_wavelet\_info}] is a list of list of dictionaries. Each outer list 
     corresponds to a list of wavelets corresponding to each drone. Every wavelet is represented
     by a dictionary, with three attributes
     
\begin{description}
  \item[1. \texttt{wavelet\_center}] The cartesian coordinates of the center $H$ of the 
          wavelet about which the wavelet expands.
  \item[2. \texttt{clock\_time}] The time on the global clock at which the wavelet started expanding around the 
         wavelet center $H$.
  \item[3. \texttt{matched\_package\_ids}] A list of the ids of the packages that were assigned to the wavelet 
     during its expansion around center $H$. Each such list is initialized as the empty list. 
\end{description}
     
     See \autoref{fig:wavelet_dict} to see a sequence of wavelets corresponding 
     to a single drone.   

\begin{figure}[H]
\centering
\includegraphics[width=10cm]{docs/wavelet_dict.pdf}
\caption{A sequence of wavelets corresponding to a drone which is stored as a list of dictionaries 
(each dictionary corresponding to a wavelet) 
\texttt{[\{'wavelet\_center':$H_i$, 'clock\_time':$t_i$, 'matched\_package\_ids': $M_i$\}]}.
 Each wavelet expands around $H_i$ at speed $u_i$
 starting at time $t_i$ on the global clock. Every drone has a sequence of wavelets. The $H_i$ also represent 
 handoff points where the drone either hands a package off to another drone or is handed a package by another 
 drone. Note that the usage of the letter $H$ to represent the center of
     a drone wavelet is suggestive of it also being a point where a package is handed to 
     the drone or a package is handed off to another drone.}
\end{figure}
\label{fig:wavelet_dict}


\item[D. \texttt{package\_trail\_info}]  is a list of list of dictionaries, similar to \verb|drone_wavelet_info|.  
     The \verb|i|\tss{th} element of the outer list corresponds to the trail of a package. In each trail (itself a list), we 
     record the positions of a package as well as the time on the clock $t$ at which that position was recorded. 
     We also note the id of the last drone known to have handled the package at time $t - \varepsilon$ for 
     $\varepsilon$ being an arbitrarily small positive number. 

     Two helper functions \verb|get_current_position_of_package| and \verb|get_current_speed_of_package| to extract 
     information conveniently from \verb|package_trail_info|. Again like \verb|get_last_wavelet_of_drone| the 
     result returned depends on the state of \verb|package_trail_info| at the time the function is called. 

\end{description}


%{python-mode}%
@d Basic setup @{ 
sources             = [np.asarray(source) for source in sources] 
targets             = [np.asarray(target) for target in targets] 

drone_initposns     = [ np.asarray(initposn) for (initposn, _) in drone_info ]
drone_speeds        = [ speed                for (_,    speed) in drone_info ]

numpackages         = len(sources) 
numdrones           = len(drone_info)

package_delivered_p = [ False for _ in range(numpackages) ] 
drone_locked_p      = [ False for _ in range(numdrones)   ]

drone_pool          = range(numdrones)
remaining_packages  = range(numpackages)
global_clock_time   = 0.0
#.............................................................................
drone_wavelets_info = [ [{'wavelet_center'        : posn,
                          'clock_time'            : 0.0,
                          'matched_package_ids'   : []}] 
                        for posn in drone_initposns ]

def get_last_wavelet_of_drone(i):
         return drone_wavelets_info[i][-1]
#.............................................................................
package_trail_info  = [ [{'current_position'   : source, 
                          'clock_time'         : 0.0,
                          'current_handler_id' : None }] 
                        for source in sources ]

def get_current_position_of_package(i):
         return package_trail_info[i][-1]['current_position']
    
def get_current_speed_of_package(i):
         current_handler_id = package_trail_info[i][-1]['current_handler_id']

         if current_handler_id is None:
              return 0.0
         else:
              return drone_speeds[current_handler_id]

def get_current_handler_of_package(i):
         return package_trail_info[i][-1]['current_handler_id']

def dronelabel(idx):
    return 'drone_' + str(idx)

def packagelabel(idx):
    return 'package_' + str(idx)

@| get_last_wavelet_of_drone, get_current_position_of_package, 
   get_current_speed_of_package, dronelabel, packagelabel @}
%{/python-mode}%

 The \verb|get_wavelet_of_drone| function defined at the end of the above chunk is a convenience function 
 for returning the center of the last wavelet and the associated clock time recorded at that center
 for an arbitrary drone.  \textbf{Note:} The result of calling this function depends on the time at which it 
 is called because \verb|drone_wavelet_info| list is mutated during the main while loop.

\subsubsection{Main Loop}
\label{ssec:mainloopmatchmove}

% Each iteration corresponds to processing exactly one event. There are 
% exactly two types of (mutually exclusive) events in this algorithm. 

% \begin{description}
% \item[Type \rnum{1}:] A package gets delivered to its assigned destination. 
% \item[Type \rnum{2}:] A wavelet corresponding to a drone (not handling a package) meets up with 
%    a drone currently handling a package. 
% \end{description}

% In both event types, a drone gets taken out of the drone pool:  for 
% the Type \rnum{1} event the 
% drone that just delivered the package to the destination; for the Type 
% \rnum{2} event the drone that just handed off the package. 

It is critical that the zero testing for upkg has 
been done for \verb|time_target_to_solo| to be computed safely 
without worrying about \verb|ZeroDivisionError|.

Note that the graph bipartite $G$ is encoded as a matrix of weights as shown in the 
figure \autoref{fig:bipart}

\begin{figure}[H]
\centering
\includegraphics[width=17cm]{docs/bipartgraph_demo.pdf}
\caption{A bipartite graph $G$ constructed between the drones 
and packages, along witht the asosciated weight matrix. Edges between
drones and packages not in the graph are represented by infinite edge 
weights. A minimum weight bipartite matching algorithm from SciPy (\url{http://bit.ly/2MAWHPn}) will 
be used as a replacement for bottleneck matching (SciPy / NetworkX do not 
have such a solver) The matrix shown in the right half of the above figure is 
built inside the code, one column at a time. }
\end{figure}
\label{fig:bipart}

%{python-mode}%
@d Construct bipartite graph $G$ on drone wavelets and package wavelets @{  
infty    = np.inf 
G_mat = np.full((len(remaining_packages),len(drone_pool)), infty)

for didx in drone_pool:
    dlabel = dronelabel(didx)

    for pidx in remaining_packages: 
        current_handler_of_package = get_current_handler_of_package(pidx)

        # CASE 1
        if current_handler_of_package != didx and \
           not(drone_locked_p[didx]):

                plabel = packagelabel(pidx)
                target = targets[pidx]
 
                pkg  = get_current_position_of_package(pidx)
                upkg = get_current_speed_of_package(pidx)
    
                wav  = get_last_wavelet_of_drone(didx)
                dro  = wav['wavelet_center']
                udro = drone_speeds[didx]
                zerotol = 1e-7

                if upkg < zerotol :
                      weight = np.linalg.norm(pkg-dro)/udro +\
                               np.linalg.norm(target-pkg)/udro

                      G_mat[pidx, didx] = weight

                elif udro > upkg and abs(upkg-udro) > zerotol:

                     time_to_target_solo = np.linalg.norm(target-pkg)/upkg
                     tI, x = get_interception_time_and_x(pkg, upkg, dro, udro, 
                                                         target, wav['clock_time'])
                     if tI < time_to_target_solo:
                          pthat = (target-pkg)/np.linalg.norm(target-pkg)
                          interception_pt = pkg + x * pthat

                          weight = tI + np.linalg.norm((target-interception_pt))/udro
                          G_mat[pidx, didx] = weight
        # CASE 2
        elif current_handler_of_package == didx and \
             drone_locked_p[didx]:
               assert abs(udro-upkg) < zerotol , "udro should be equal to upkg"
               weight = np.linalg.norm((target-pkg))/udro
               G_mat[pidx, didx] = weight
    
        # CASE 3
        elif current_handler_of_package != didx and \
             drone_locked_p[didx]:
               G_mat[pidx, didx] = infty # effectively saying there is not edge between the two
        else : 
               # the outer not negates the inner condition which is true if this branch is executed
               assert not(current_handler_of_package == didx and \
                           not(drone_locked_p[didx])) ,\
                       "This else branch should not be executed. This\
                        means didx is handling a package and is NOT locked"
@| @}
%{/python-mode}%

Since NetworkX does not have a native bottleneck matching solver, we use a minimum-weight matching solver
\footnote{by negating the edgeweights and using the maximum weighted matching solver described in 
\url{https://networkx.github.io/documentation/stable/reference/algorithms/matching.html} or \url{http://bit.ly/2MAWHPn}.  } as a replacement
/approximation to bottleneck matching. 


There are exactly two types of (mutually exclusive) 
events in this algorithm. 

\begin{description}
\item[Type \rnum{1}:] A package gets delivered to its assigned destination. 
\item[Type \rnum{2}:] A wavelet corresponding to a drone (not handling a package) meets up with 
   a drone currently handling a package. 
\end{description}


%{python-mode}%
@d Get a bottleneck matching on $G$ @{
from scipy.optimize import linear_sum_assignment
pkg_ind, dro_ind = linear_sum_assignment(G_mat)
@| @}
%{/python-mode}%

%{python-mode}%
@d Expand drone wavelets till an event of either Type \rnum{1} or Type \rnum{2} is detected @{   
pass
@| @}
%{/python-mode}%

%{python-mode}%
@d Update drone pool and package states @{   
pass
@| @}
%{/python-mode}%


%{python-mode}%
@d Run convex optimization solver to get improved tours for drones and packages @{   
pass
@| @}
%{/python-mode}%


%{python-mode}%
@d Plot movement of packages and drones if \verb|plot_tour_p == True | @{   
pass
@| @}
%{/python-mode}%

\nocite{*}
\printbibliography
\begin{appendices}

\chapter{History and Previous Work}
\begin{wrapfigure}{L}{0.5\textwidth}
  \begin{center}
      \includegraphics[width=6cm]{docs/pony-express.png}
      \caption{A job application poster and a relay route used for the Pony Express. 
      Images taken from \cite{orphans} and \cite{ponyroute} respectively.}
  \end{center}
\end{wrapfigure}

A system of using relays for delivering packages is not a particularly new idea. A 
famous (and shortlived!) example of such a relay system was the Pony Express company which 
was used a system of a relay of horse riders tp transport mail from St. Joseph, Missouri to 
Sacramento, California. 

To quote the Wikipedia article

\begin{quote}
\textit{``Operated by Central Overland California and Pike's Peak Express Company, the Pony Express was a great 
financial investment to the U.S. During its 18 months of operation, it reduced the time for messages to travel 
between the Atlantic and Pacific coasts to about 10 days. It became the West's most direct means of east-west 
communication before the transcontinental telegraph was established (October 24, 1861), and was vital for tying 
the new U.S. state of California with the rest of the United States.The Pony Express demonstrated that a unified 
transcontinental system of communications could be established and operated year-round. ''}
\end{quote}


While the invention of the telegraph might have run the Pony Express out of business, the idea of using relay agents 
such as drones --- instead of horses! --- to transfer packages can have applications today for sending physical goods 
(which of course can't be telegraphed! \Winkey) such as  life-saving medicinces in under-developed 
countries or in disaster relief areas. 
ZipLine\cite{zipline} \cite{zipline-ted} and Matternet \cite{matternet} are just two of the companies which 
are involved in building networks of drones for precisely such missions.

\begin{figure}[H]
  \centering
  \includegraphics[width=12cm]{docs/dabba.jpg}
  \caption{Dabbawallas exchanging lunchboxes (dabbas) at a relay point. Image from \cite{Magazine2019Oct} }
\end{figure}

Another relay system for package deliveries (135 years old and still functioning!) is that of 
the \textit{dabbawallas} \footnote{literally: lunchbox carriers} used for transporting lunch boxes from 
homes and restaurants to people at work in Mumbai, India. To quote from \cite{dabba}
\begin{quote}
\textit{Four thousand five hundred semi-literate dabbawalas collect and deliver 175,000 packages 
within hours. What should we learn from this unique, simple and highly efficient 120-year-old 
logistics system? [\ldots] After the customer leaves for work, her lunch is packed into a tiffin 
provided by the dabbawala. A color-coded notation on the handle identifies its owner and destination. 
Once the dabbawala has picked up the tiffin, he moves fast using a combination of bicycles, trains and his 
two feet.}

\textit{A BBC crew filming dabbawalas in action was amazed at their speed. ``Following our dabbawala 
wasn't easy, our film crew quickly lost him in the congestion of the train station. At Victoria 
Terminus we found other fast moving dabbawalas, but not our subject... and at Mr Bhapat's ayurvedic 
pharmacy, the lunch had arrived long before the film crew,'' the documentary noted wryly. So, how do 
they work so efficiently?}

\textit{The entire system depends on teamwork and meticulous timing. Tiffins are collected from homes 
between 7.00 am and 9.00 am, and taken to the nearest railway station. At various intermediary stations, 
they are hauled onto platforms and sorted out for area-wise distribution, so that a single tiffin could 
change hands three to four times in the course of its daily journey.}

\textit{At Mumbai's downtown stations, the last link in the chain, a final relay of dabbawalas fan 
out to the tiffins' destined bellies. Lunch hour over, the whole process moves into reverse and the 
tiffins return to suburban homes by 6.00 pm.}
\end{quote}

See \url{https://youtu.be/dX-0el2wuEU} for a short video on the dabbawallas. 


\chapter{\texttt{README.md}}

This \verb|README| file can be read more clearly alongside its appropriate formatting at \\
\url{https://github.com/gtelang/PackageHandoff_Python/tree/master/packagehandoff_lit}

@O README.md -cp @{    
To run this code, you will need a distribution of Python 2.7.12 along 
with the following libraries

- networkx
- matplotlib
- numpy 
- scipy
- cgal-bindings
- cvxpy

All source code is contained in the .web file. If you modify the file, the 
resulting code and corresponding description file can be weaved and tangled 
with the script `weave-tangle.sh`. You will need the 

- [pdflatex](https://linux.die.net/man/1/pdflatex)
- [nuweb](http://nuweb.sourceforge.net/) 
- [asymptote](http://asymptote.sourceforge.net/) 
  
executables to be somewhere on your system's path. 

All source code is in the `src' directory. The asy2d, asy3d and docs
folders can be neglected since they contain images and documents 
referenced in the `packagehandoff.pdf' file. From the point of view of 
_running_ the code they can be ignored. 



@|  @}




\chapter{\texttt{utils\char`_graphics.py}}

This file contains useful functions for visualization and plotting functions described in the previous chapters.
%{python-mode}%
@O src/utils_graphics.py -cp @{    
from matplotlib import rc
from colorama import Fore
from colorama import Style
from scipy.optimize import minimize
from sklearn.cluster import KMeans
import argparse
import itertools
import math
import matplotlib as mpl
import matplotlib.pyplot as plt
import numpy as np
import os
import pprint as pp
import randomcolor 
import sys
import time

xlim, ylim = [0,1], [0,1]

# Borrowed from https://stackoverflow.com/a/9701141
import numpy as np
import colorsys

def get_colors(num_colors, lightness=0.2):
    colors=[]
    for i in np.arange(60., 360., 300. / num_colors):
        hue        = i/360.0
        saturation = 0.95
        colors.append(colorsys.hls_to_rgb(hue, lightness, saturation))
    return colors
@|  @}
%{/python-mode}%

\newpage

\chapter{\texttt{utils\char`_algo.py}}

This file contains useful functions for writing algorithms described in the previous chapters.

%{python-mode}%
@O src/utils_algo.py -cp @{
import numpy as np
import random
from colorama import Fore
from colorama import Style

def vector_chain_from_point_list(pts):
    vec_chain = []
    for pair in zip(pts, pts[1:]):
        tail= np.array (pair[0])
        head= np.array (pair[1])
        vec_chain.append(head-tail)

    return vec_chain

def length_polygonal_chain(pts):
    vec_chain = vector_chain_from_point_list(pts)

    acc = 0
    for vec in vec_chain:
        acc = acc + np.linalg.norm(vec)
    return acc
def pointify_vector (x):
    if len(x) % 2 == 0:
        pts = []
        for i in range(len(x))[::2]:
            pts.append( [x[i],x[i+1]] )
        return pts
    else :
        sys.exit('List of items does not have an even length to be able to be pointifyed')
def flatten_list_of_lists(l):
       return [item for sublist in l for item in sublist]
def print_list(xs):
    for x in xs:
        print x
def partial_sums( xs ):
    psum = 0
    acc = []
    for x in xs:
        psum = psum+x
        acc.append( psum )
    return acc
def are_site_orderings_equal(sites1, sites2):

    for (x1,y1), (x2,y2) in zip(sites1, sites2): 
        if (x1-x2)**2 + (y1-y2)**2 > 1e-8:
            return False
    return True
def bunch_of_non_uniform_random_points(numpts):
    cluster_size = int(np.sqrt(numpts)) 
    numcenters   = cluster_size
    
    import scipy
    import random
    centers = scipy.rand(numcenters,2).tolist()

    scale, points = 4.0, []
    for c in centers:
        cx, cy = c[0], c[1]
        # For current center $c$ of this loop, generate \verb|cluster_size| points uniformly in a square centered at it
           
        sq_size      = min(cx,1-cx,cy, 1-cy)
        loc_pts_x    = np.random.uniform(low=cx-sq_size/scale, high=cx+sq_size/scale, size=(cluster_size,))
        loc_pts_y    = np.random.uniform(low=cy-sq_size/scale, high=cy+sq_size/scale, size=(cluster_size,))
        points.extend(zip(loc_pts_x, loc_pts_y))
        

    # Whatever number of points are left to be generated, generate them uniformly inside the unit-square
       
    num_remaining_pts = numpts - cluster_size * numcenters
    remaining_pts = scipy.rand(num_remaining_pts, 2).tolist()
    points.extend(remaining_pts)
    

    return points
    
def write_to_yaml_file(data, dir_name, file_name):
   import yaml
   with open(dir_name + '/' + file_name, 'w') as outfile:
     yaml.dump( data, outfile, default_flow_style = False)
@|  @}
%{/python-mode}%

\chapter{Implementation of \textlangle \texttt{Run Handlers}\textrangle}

This chunk contains code required for the interactive input of sites and agents onto the canvas. 

%{python-mode}%
@D Run Handlers @{
# Set up logging information relevant to this module
logger=logging.getLogger(__name__)
logging.basicConfig(level=logging.DEBUG)

def debug(msg):
    frame,filename,line_number,function_name,lines,index=inspect.getouterframes(
        inspect.currentframe())[1]
    line=lines[0]
    indentation_level=line.find(line.lstrip())
    logger.debug('{i} [{m}]'.format(
        i='.'*indentation_level, m=msg))


def info(msg):
    frame,filename,line_number,function_name,lines,index=inspect.getouterframes(
        inspect.currentframe())[1]
    line=lines[0]
    indentation_level=line.find(line.lstrip())
    logger.info('{i} [{m}]'.format(
        i='.'*indentation_level, m=msg))

xlim, ylim = [0,1], [0,1]

def applyAxCorrection(ax):
      ax.set_xlim([xlim[0], xlim[1]])
      ax.set_ylim([ylim[0], ylim[1]])
      ax.set_aspect(1.0)

def clearPatches(ax):
    # Get indices cooresponding to the polygon patches
    for index , patch in zip(range(len(ax.patches)), ax.patches):
        if isinstance(patch, mpl.patches.Polygon) == True:
            patch.remove()
    ax.lines[:]=[]
    applyAxCorrection(ax)

def clearAxPolygonPatches(ax):

    # Get indices cooresponding to the polygon patches
    for index , patch in zip(range(len(ax.patches)), ax.patches):
        if isinstance(patch, mpl.patches.Polygon) == True:
            patch.remove()
    ax.lines[:]=[]
    applyAxCorrection(ax)

class Single_PHO_Input:
    def __init__(self, drone_info = [] , source = None, target=None):
           self.drone_info = drone_info 
           self.source     = source
           self.target     = target

    def get_drone_pis (self):
           return [self.drone_info[idx][0] for idx in range(len(self.drone_info)) ]
           
    def get_drone_uis (self):
           return [self.drone_info[idx][1] for idx in range(len(self.drone_info)) ]
         
    def get_tour(self, algo, plot_tour_p=False):
           return algo( self.drone_info, 
                        self.source, 
                        self.target, 
                        plot_tour_p    )

    # Methods for \verb|ReverseHorseflyInput|
    def clearAllStates (self):
          self.drone_info = []
          self.source = None
          self.target = None

def single_pho_run_handler():
    import random
    def wrapperEnterRunPoints(fig, ax, run):
      def _enterPoints(event):
        if event.name      == 'button_press_event'          and \
           (event.button   == 1 or event.button == 3)       and \
            event.dblclick == True and event.xdata  != None and event.ydata  != None:

             if event.button == 1:  
                 # Insert blue circle representing the initial position of a drone
                 print Fore.GREEN
                 newPoint = (event.xdata, event.ydata)
                 speed    = np.random.uniform() # float(raw_input('What speed do you want for the drone at '+str(newPoint)))
                 run.drone_info.append( (newPoint, speed) ) 
                 patchSize  = (xlim[1]-xlim[0])/40.0
                 print Style.RESET_ALL
                 
                 ax.add_patch( mpl.patches.Circle( newPoint, radius = patchSize,
                                                   facecolor='#b7e8cc', edgecolor='black'  ))

                 ax.text( newPoint[0], newPoint[1], "{:.2f}".format(speed), fontsize=15, 
                          horizontalalignment='center', verticalalignment='center' )

                 ax.set_title('Number of drones inserted: ' +\
                              str(len(run.drone_info)), fontdict={'fontsize':25})
                 
             elif event.button == 3:  
                 # Insert big red circles representing the source and target points
                 patchSize  = (xlim[1]-xlim[0])/50.0
                 if run.source is None:    
                      run.source = (event.xdata, event.ydata)  
                      ax.add_patch( mpl.patches.Circle( run.source, radius = patchSize, 
                                                        facecolor= '#ffd9d6', edgecolor='black', lw=1.0 ))
                      ax.text( run.source[0], run.source[1], 'S', fontsize=15, 
                               horizontalalignment='center', verticalalignment='center' )

                 elif run.target is None:
                      run.target = (event.xdata, event.ydata)  
                      ax.add_patch( mpl.patches.Circle( run.target, radius = patchSize, 
                                                       facecolor= '#ffd9d6', edgecolor='black', lw=1.0 ))
                      ax.text( run.target[0], run.target[1], 'T', fontsize=15, 
                               horizontalalignment='center', verticalalignment='center' )
                 else:
                       print Fore.RED, "Source and Target already set", Style.RESET_ALL
             # Clear polygon patches and set up last minute \verb|ax| tweaks
             clearAxPolygonPatches(ax)
             applyAxCorrection(ax)
             fig.canvas.draw()
      return _enterPoints

    # The key-stack argument is mutable! I am using this hack to my advantage.
    def wrapperkeyPressHandler(fig, ax, run): 
           def _keyPressHandler(event):
               if event.key in ['i', 'I']:  

                    # Select algorithm to execute
                    algo_str = raw_input(Fore.YELLOW                                             +\
                            "Enter algorithm to be used to compute the tour:\n Options are:\n"   +\
                            " (odw)     One Dimensional Wavefront \n"                            +\
                            Style.RESET_ALL)

                    algo_str = algo_str.lstrip()
                     
                    # Incase there are patches present from the previous clustering, just clear them
                    clearAxPolygonPatches(ax)
                    if   algo_str == 'odw':
                          tour = run.get_tour( algo_odw, plot_tour_p=True )
                    else:
                          print "Unknown option. No horsefly for you! ;-D "
                          sys.exit()
                    applyAxCorrection(ax)
                    fig.canvas.draw()
                    
               elif event.key in ['c', 'C']: 
                    # Clear canvas and states of all objects
                    run.clearAllStates()
                    ax.cla()
                                  
                    applyAxCorrection(ax)
                    ax.set_xticks([])
                    ax.set_yticks([])
                                     
                    fig.texts = []
                    fig.canvas.draw()
           return _keyPressHandler
    
    # Set up interactive canvas
    fig, ax =  plt.subplots()
    run = Single_PHO_Input()
        
    from matplotlib import rc
    
    # specify the custom font to use
    plt.rcParams['font.family'] = 'sans-serif'
    plt.rcParams['font.sans-serif'] = 'Times New Roman'

    xlim = utils_graphics.xlim
    ylim = utils_graphics.ylim

    ax.set_xlim([xlim[0], xlim[1]])
    ax.set_ylim([ylim[0], ylim[1]])
    ax.set_aspect(1.0)
    ax.set_xticks([])
    ax.set_yticks([])
          
    ax.set_title("Enter drone positions, source and target onto canvas. \n \
(Enter speeds into the terminal, after inserting a drone at a particular position)")

    mouseClick   = wrapperEnterRunPoints (fig,ax, run)
    fig.canvas.mpl_connect('button_press_event' , mouseClick)
          
    keyPress     = wrapperkeyPressHandler(fig,ax, run)
    fig.canvas.mpl_connect('key_press_event', keyPress   )
    
    plt.show()





class Multiple_PHO_Input:
    def __init__(self, drone_info = [] , sources = [], targets=[]):
           self.drone_info = drone_info 
           self.sources     = sources
           self.targets     = targets

    def get_drone_pis (self):
           return [self.drone_info[idx][0] for idx in range(len(self.drone_info)) ]
           
    def get_drone_uis (self):
           return [self.drone_info[idx][1] for idx in range(len(self.drone_info)) ]
         
    def get_tour(self, algo, plot_tour_p=False):
           return algo( self.drone_info, 
                        self.sources, 
                        self.targets, 
                        plot_tour_p    )

    # Methods for \verb|ReverseHorseflyInput|
    def clearAllStates (self):
          self.drone_info = []
          self.sources = []
          self.targets = []



def multiple_pho_run_handler():
    import random
    def wrapperEnterRunPoints(fig, ax, run):
      def _enterPoints(event):
        if event.name      == 'button_press_event'          and \
           (event.button   == 1 or event.button == 3)       and \
            event.dblclick == True and event.xdata  != None and event.ydata  != None:

             if event.button == 1:  
                 # Insert circle representing the initial position of a drone
                 print Fore.GREEN
                 newPoint = (event.xdata, event.ydata)
                 speed    = np.random.uniform() # float(raw_input('What speed do you want for the drone at '+str(newPoint)))
                 run.drone_info.append( (newPoint, speed) ) 
                 patchSize  = (xlim[1]-xlim[0])/40.0
                 print Style.RESET_ALL
                 
                 ax.add_patch( mpl.patches.Circle( newPoint, radius = patchSize,
                                                   facecolor='#EBEBEB', edgecolor='black'  ))

                 ax.text( newPoint[0], newPoint[1], "{:.2f}".format(speed), fontsize=10, 
                          horizontalalignment='center', verticalalignment='center' )

                 ax.set_title('Number of drones inserted: ' +\
                              str(len(run.drone_info)), fontdict={'fontsize':25})
                 
             elif event.button == 3:  
                 # distinct colors, obtained from https://sashat.me/2017/01/11/list-of-20-simple-distinct-colors/
                 cols = ['#e6194b', '#3cb44b', '#ffe119', '#4363d8', '#f58231', 
                 '#911eb4', '#46f0f0', '#f032e6', '#bcf60c', '#fabebe', 
                 '#008080', '#e6beff', '#9a6324', '#fffac8', '#800000', 
                 '#aaffc3', '#808000', '#ffd8b1', '#000075', '#808080'] 

                 # Insert big colored circles representing the source and target points

                 patchSize  = (xlim[1]-xlim[0])/50.0
                 if (len(run.sources) + len(run.targets)) % 2 == 0 : 
                        run.sources.append((event.xdata, event.ydata))
                        ax.add_patch( mpl.patches.Circle( run.sources[-1], radius = patchSize, 
                                                   facecolor= cols[len(run.sources) % len(cols)], edgecolor='black', lw=1.0 ))
                        ax.text( run.sources[-1][0], run.sources[-1][1], 'S'+str(len(run.sources)), fontsize=15, 
                                 horizontalalignment='center', verticalalignment='center' )

                 else :
                      run.targets.append((event.xdata, event.ydata))
                      ax.add_patch( mpl.patches.Circle( run.targets[-1], radius = patchSize, 
                                                       facecolor= cols[len(run.sources)%len(cols)], edgecolor='black', lw=1.0 ))
                      ax.text( run.targets[-1][0], run.targets[-1][1], 'T'+str(len(run.targets)), fontsize=15, 
                               horizontalalignment='center', verticalalignment='center' )

             # Clear polygon patches and set up last minute \verb|ax| tweaks
             clearAxPolygonPatches(ax)
             applyAxCorrection(ax)
             fig.canvas.draw()
      return _enterPoints

    # The key-stack argument is mutable! I am using this hack to my advantage.
    def wrapperkeyPressHandler(fig, ax, run): 
           def _keyPressHandler(event):
               if event.key in ['i', 'I']:  

                    # Select algorithm to execute
                    algo_str = raw_input(Fore.YELLOW                                             +\
                            "Enter algorithm to be used to compute the tour:\n Options are:\n"   +\
                            " (mm)     Match-and-move \n"                            +\
                            Style.RESET_ALL)

                    algo_str = algo_str.lstrip()
                     
                    # Incase there are patches present from the previous clustering, just clear them
                    clearAxPolygonPatches(ax)
                    if   algo_str == 'mm':
                          tour = run.get_tour( algo_matchmove, plot_tour_p=True )
                    else:
                          print "Unknown option. No horsefly for you! ;-D "
                          sys.exit()
                    applyAxCorrection(ax)
                    fig.canvas.draw()
                    
               elif event.key in ['c', 'C']: 
                    # Clear canvas and states of all objects
                    run.clearAllStates()
                    ax.cla()
                                  
                    applyAxCorrection(ax)
                    ax.set_xticks([])
                    ax.set_yticks([])
                                     
                    fig.texts = []
                    fig.canvas.draw()
           return _keyPressHandler
    
    # Set up interactive canvas
    fig, ax =  plt.subplots()
    run = Multiple_PHO_Input()
        
    from matplotlib import rc
    
    # specify the custom font to use
    plt.rcParams['font.family'] = 'sans-serif'
    plt.rcParams['font.sans-serif'] = 'Times New Roman'

    xlim = utils_graphics.xlim
    ylim = utils_graphics.ylim

    ax.set_xlim([xlim[0], xlim[1]])
    ax.set_ylim([ylim[0], ylim[1]])
    ax.set_aspect(1.0)
    ax.set_xticks([])
    ax.set_yticks([])
          
    ax.set_title("Enter drone positions, sources and targets onto canvas.")

    mouseClick   = wrapperEnterRunPoints (fig,ax, run)
    fig.canvas.mpl_connect('button_press_event' , mouseClick)
          
    keyPress     = wrapperkeyPressHandler(fig,ax, run)
    fig.canvas.mpl_connect('key_press_event', keyPress   )
    
    plt.show()



@| @}
%{/python-mode}%

\chapter{Implementation of \textlangle\texttt{Plotting}\textrangle}

We typically plot the tours onto a separate window if the boolean switch \verb|plot_tour_p| 
is set to \verb|True| while calling the algorithm. The path of the package is shown in bold red. 
The paths of the drones from their initial positions to the point where they pick up the package 
from another drone are shown in blue.

An example output from the \verb|plot_tour| function is shown below.

\begin{figure}[H]
\centering
\includegraphics[width=8cm]{docs/pho_example_plot.pdf}
\caption{The numbers inside the circle indicate the speed of the drone}
\end{figure}

%{python-mode}%
@D Plotting @{
def plot_tour(fig, ax, figtitle, source, target, 
              drone_info, used_drones, package_trail,
              xlims=[0,1],
              ylims=[0,1],
              aspect_ratio=1.0,
              speedfontsize=10,
              speedmarkersize=20,
              sourcetargetmarkerfontsize=15,
              sourcetargetmarkersize=20 ):

    import matplotlib.ticker as ticker
    ax.set_aspect(aspect_ratio)
    ax.set_xlim(xlims)
    ax.set_ylim(ylims)

    plt.rc('font', family='serif')

    # Draw the package trail
    xs, ys = extract_coordinates(package_trail)
    ax.plot(xs,ys, 'ro', markersize=5 )
    for idx in range(len(xs)-1):
          plt.arrow( xs[idx], ys[idx], xs[idx+1]-xs[idx], ys[idx+1]-ys[idx], 
                    **{'length_includes_head': True, 
                       'width': 0.007 , 
                       'head_width':0.025, 
                       'fc': 'r', 
                       'ec': 'none',
                       'alpha': 0.8})


    # Draw the source, target, and initial positions of the robots as bold dots
    xs,ys = extract_coordinates([source, target])
    ax.plot(xs,ys, 'o', markersize=sourcetargetmarkersize, alpha=1.0, ms=10, mec='k', mfc='#F1AB30' )
    #ax.plot(xs,ys, 'k--', alpha=0.6 ) # light line connecting source and target

    ax.text(source[0], source[1], 'S', fontsize=sourcetargetmarkerfontsize,\
            horizontalalignment='center',verticalalignment='center')
    ax.text(target[0], target[1], 'T', fontsize=sourcetargetmarkerfontsize,\
            horizontalalignment='center',verticalalignment='center')

    xs, ys = extract_coordinates( [ drone_info[idx][0] for idx in range(len(drone_info)) ]  )
    ax.plot(xs,ys, 'o', markersize=speedmarkersize, alpha = 1.0, mec='None', mfc='#b7e8cc' )

    # Draw speed labels
    for idx in range(len(drone_info)):
         ax.text( drone_info[idx][0][0], drone_info[idx][0][1], format(drone_info[idx][1],'.2f'),
                  fontsize=speedfontsize, horizontalalignment='center', verticalalignment='center' )

    # Draw drone path from initial position to interception point
    for pt, idx in zip(package_trail, used_drones):
         initdroneposn = drone_info[idx][0]
         handoffpoint  = pt
    
         xs, ys = extract_coordinates([initdroneposn, handoffpoint])
         plt.arrow( xs[0], ys[0], xs[1]-xs[0], ys[1]-ys[0], 
                    **{'length_includes_head': True, 
                       'width': 0.005 , 
                       'head_width':0.02, 
                       'fc': 'b', 
                       'ec': 'none'})

    fig.suptitle(figtitle, fontsize=15)
    ax.set_title('\nMakespan: ' + format(makespan(drone_info, used_drones, package_trail),'.5f'), fontsize=16)

    startx, endx = ax.get_xlim()
    starty, endy = ax.get_ylim()


    ax.tick_params(which='both', # Options for both major and minor ticks
                top='off', # turn off top ticks
                left='off', # turn off left ticks
                right='off',  # turn off right ticks
                bottom='off') # turn off bottom ticks
    
    # Customize the major grid
    ax.grid(which='major', linestyle='-', linewidth='0.1', color='red')
    ax.grid(which='minor', linestyle=':', linewidth='0.1', color='black')

    #ax.xaxis.set_ticks(np.arange(startx, endx, 0.4))
    #ax.xaxis.set_major_formatter(ticker.FormatStrFormatter('%0.1f'))
     
    #ax.yaxis.set_ticks(np.arange(starty, endy, 0.4))
    #ax.yaxis.set_major_formatter(ticker.FormatStrFormatter('%0.1f'))

    #plt.yticks(fontsize=5, rotation=90)
    #plt.xticks(fontsize=5)

    # A light grid
    #plt.grid(color='0.5', linestyle='--', linewidth=0.5)
@| @}
%{/python-mode}%





\end{appendices}
%---------------------
\listoftodos
%---------------------
\end{document}
